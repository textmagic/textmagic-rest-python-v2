# coding: utf-8

"""
    TextMagic API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 2
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from TextMagic.api_client import ApiClient


class TextMagicApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def assign_contacts_to_list(self, assign_contacts_to_list_input_object, id, **kwargs):  # noqa: E501
        """Assign contacts to a list  # noqa: E501

        > Unlike all other PUT requests, this command does not need old contact IDs to be submitted. For example, if you have a list with contacts 150, 151 and 152 and you want to add contact ID 153, you only need to submit 153 as a parameter of PUT /api/v2/lists/{id}/contacts.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_contacts_to_list(assign_contacts_to_list_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AssignContactsToListInputObject assign_contacts_to_list_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.assign_contacts_to_list_with_http_info(assign_contacts_to_list_input_object, id, **kwargs)  # noqa: E501
        else:
            (data) = self.assign_contacts_to_list_with_http_info(assign_contacts_to_list_input_object, id, **kwargs)  # noqa: E501
            return data

    def assign_contacts_to_list_with_http_info(self, assign_contacts_to_list_input_object, id, **kwargs):  # noqa: E501
        """Assign contacts to a list  # noqa: E501

        > Unlike all other PUT requests, this command does not need old contact IDs to be submitted. For example, if you have a list with contacts 150, 151 and 152 and you want to add contact ID 153, you only need to submit 153 as a parameter of PUT /api/v2/lists/{id}/contacts.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.assign_contacts_to_list_with_http_info(assign_contacts_to_list_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AssignContactsToListInputObject assign_contacts_to_list_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['assign_contacts_to_list_input_object', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method assign_contacts_to_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'assign_contacts_to_list_input_object' is set
        if ('assign_contacts_to_list_input_object' not in params or
                params['assign_contacts_to_list_input_object'] is None):
            raise ValueError("Missing the required parameter `assign_contacts_to_list_input_object` when calling `assign_contacts_to_list`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `assign_contacts_to_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'assign_contacts_to_list_input_object' in params:
            body_params = params['assign_contacts_to_list_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/{id}/contacts', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def block_contact(self, block_contact_input_object, **kwargs):  # noqa: E501
        """Block contact by phone number  # noqa: E501

        Block contact from inbound and outbound communication by phone number.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.block_contact(block_contact_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BlockContactInputObject block_contact_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.block_contact_with_http_info(block_contact_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.block_contact_with_http_info(block_contact_input_object, **kwargs)  # noqa: E501
            return data

    def block_contact_with_http_info(self, block_contact_input_object, **kwargs):  # noqa: E501
        """Block contact by phone number  # noqa: E501

        Block contact from inbound and outbound communication by phone number.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.block_contact_with_http_info(block_contact_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BlockContactInputObject block_contact_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['block_contact_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method block_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'block_contact_input_object' is set
        if ('block_contact_input_object' not in params or
                params['block_contact_input_object'] is None):
            raise ValueError("Missing the required parameter `block_contact_input_object` when calling `block_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'block_contact_input_object' in params:
            body_params = params['block_contact_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/block', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def buy_dedicated_number(self, buy_dedicated_number_input_object, **kwargs):  # noqa: E501
        """Buy a dedicated number  # noqa: E501

        To buy a dedicated number, you first need to find an available number matching your criteria using the `/api/v2/numbers/available` command described above.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.buy_dedicated_number(buy_dedicated_number_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BuyDedicatedNumberInputObject buy_dedicated_number_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.buy_dedicated_number_with_http_info(buy_dedicated_number_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.buy_dedicated_number_with_http_info(buy_dedicated_number_input_object, **kwargs)  # noqa: E501
            return data

    def buy_dedicated_number_with_http_info(self, buy_dedicated_number_input_object, **kwargs):  # noqa: E501
        """Buy a dedicated number  # noqa: E501

        To buy a dedicated number, you first need to find an available number matching your criteria using the `/api/v2/numbers/available` command described above.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.buy_dedicated_number_with_http_info(buy_dedicated_number_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BuyDedicatedNumberInputObject buy_dedicated_number_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['buy_dedicated_number_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method buy_dedicated_number" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'buy_dedicated_number_input_object' is set
        if ('buy_dedicated_number_input_object' not in params or
                params['buy_dedicated_number_input_object'] is None):
            raise ValueError("Missing the required parameter `buy_dedicated_number_input_object` when calling `buy_dedicated_number`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'buy_dedicated_number_input_object' in params:
            body_params = params['buy_dedicated_number_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/numbers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cancel_verification(self, verify_id, **kwargs):  # noqa: E501
        """Cancel verification process  # noqa: E501

        You can cancel the verification not earlier than 30 seconds after the initial request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_verification(verify_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str verify_id: the verifyId that you received in Step 1. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cancel_verification_with_http_info(verify_id, **kwargs)  # noqa: E501
        else:
            (data) = self.cancel_verification_with_http_info(verify_id, **kwargs)  # noqa: E501
            return data

    def cancel_verification_with_http_info(self, verify_id, **kwargs):  # noqa: E501
        """Cancel verification process  # noqa: E501

        You can cancel the verification not earlier than 30 seconds after the initial request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_verification_with_http_info(verify_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str verify_id: the verifyId that you received in Step 1. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['verify_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_verification" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'verify_id' is set
        if ('verify_id' not in params or
                params['verify_id'] is None):
            raise ValueError("Missing the required parameter `verify_id` when calling `cancel_verification`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'verify_id' in params:
            path_params['verifyId'] = params['verify_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/verify/{verifyId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_phone_verification_code_tfa(self, check_phone_verification_code_input_object, **kwargs):  # noqa: E501
        """Step 2: Check the verification code   # noqa: E501

        Check received code from user with the code which was actually sent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_phone_verification_code_tfa(check_phone_verification_code_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CheckPhoneVerificationCodeInputObject check_phone_verification_code_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.check_phone_verification_code_tfa_with_http_info(check_phone_verification_code_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.check_phone_verification_code_tfa_with_http_info(check_phone_verification_code_input_object, **kwargs)  # noqa: E501
            return data

    def check_phone_verification_code_tfa_with_http_info(self, check_phone_verification_code_input_object, **kwargs):  # noqa: E501
        """Step 2: Check the verification code   # noqa: E501

        Check received code from user with the code which was actually sent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_phone_verification_code_tfa_with_http_info(check_phone_verification_code_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CheckPhoneVerificationCodeInputObject check_phone_verification_code_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['check_phone_verification_code_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_phone_verification_code_tfa" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'check_phone_verification_code_input_object' is set
        if ('check_phone_verification_code_input_object' not in params or
                params['check_phone_verification_code_input_object'] is None):
            raise ValueError("Missing the required parameter `check_phone_verification_code_input_object` when calling `check_phone_verification_code_tfa`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'check_phone_verification_code_input_object' in params:
            body_params = params['check_phone_verification_code_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/verify', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def clear_and_assign_contacts_to_list(self, clear_and_assign_contacts_to_list_input_object, id, **kwargs):  # noqa: E501
        """Reset list members to the specified contacts  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_and_assign_contacts_to_list(clear_and_assign_contacts_to_list_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClearAndAssignContactsToListInputObject clear_and_assign_contacts_to_list_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.clear_and_assign_contacts_to_list_with_http_info(clear_and_assign_contacts_to_list_input_object, id, **kwargs)  # noqa: E501
        else:
            (data) = self.clear_and_assign_contacts_to_list_with_http_info(clear_and_assign_contacts_to_list_input_object, id, **kwargs)  # noqa: E501
            return data

    def clear_and_assign_contacts_to_list_with_http_info(self, clear_and_assign_contacts_to_list_input_object, id, **kwargs):  # noqa: E501
        """Reset list members to the specified contacts  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_and_assign_contacts_to_list_with_http_info(clear_and_assign_contacts_to_list_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ClearAndAssignContactsToListInputObject clear_and_assign_contacts_to_list_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['clear_and_assign_contacts_to_list_input_object', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clear_and_assign_contacts_to_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'clear_and_assign_contacts_to_list_input_object' is set
        if ('clear_and_assign_contacts_to_list_input_object' not in params or
                params['clear_and_assign_contacts_to_list_input_object'] is None):
            raise ValueError("Missing the required parameter `clear_and_assign_contacts_to_list_input_object` when calling `clear_and_assign_contacts_to_list`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `clear_and_assign_contacts_to_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'clear_and_assign_contacts_to_list_input_object' in params:
            body_params = params['clear_and_assign_contacts_to_list_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/{id}/contacts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def close_chats_bulk(self, close_chats_bulk_input_object, **kwargs):  # noqa: E501
        """Close chats (bulk)  # noqa: E501

        Close chats by chat IDs or close all chats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.close_chats_bulk(close_chats_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CloseChatsBulkInputObject close_chats_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.close_chats_bulk_with_http_info(close_chats_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.close_chats_bulk_with_http_info(close_chats_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def close_chats_bulk_with_http_info(self, close_chats_bulk_input_object, **kwargs):  # noqa: E501
        """Close chats (bulk)  # noqa: E501

        Close chats by chat IDs or close all chats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.close_chats_bulk_with_http_info(close_chats_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CloseChatsBulkInputObject close_chats_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['close_chats_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method close_chats_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'close_chats_bulk_input_object' is set
        if ('close_chats_bulk_input_object' not in params or
                params['close_chats_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `close_chats_bulk_input_object` when calling `close_chats_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'close_chats_bulk_input_object' in params:
            body_params = params['close_chats_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/close/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def close_read_chats(self, **kwargs):  # noqa: E501
        """Close read chats  # noqa: E501

        Close all chats that have no unread messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.close_read_chats(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.close_read_chats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.close_read_chats_with_http_info(**kwargs)  # noqa: E501
            return data

    def close_read_chats_with_http_info(self, **kwargs):  # noqa: E501
        """Close read chats  # noqa: E501

        Close all chats that have no unread messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.close_read_chats_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method close_read_chats" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/close/read', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def close_subaccount(self, id, **kwargs):  # noqa: E501
        """Close sub-account  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.close_subaccount(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.close_subaccount_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.close_subaccount_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def close_subaccount_with_http_info(self, id, **kwargs):  # noqa: E501
        """Close sub-account  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.close_subaccount_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method close_subaccount" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `close_subaccount`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/subaccounts/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_contact(self, create_contact_input_object, **kwargs):  # noqa: E501
        """Add a new contact  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact(create_contact_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateContactInputObject create_contact_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_contact_with_http_info(create_contact_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.create_contact_with_http_info(create_contact_input_object, **kwargs)  # noqa: E501
            return data

    def create_contact_with_http_info(self, create_contact_input_object, **kwargs):  # noqa: E501
        """Add a new contact  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_with_http_info(create_contact_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateContactInputObject create_contact_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['create_contact_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'create_contact_input_object' is set
        if ('create_contact_input_object' not in params or
                params['create_contact_input_object'] is None):
            raise ValueError("Missing the required parameter `create_contact_input_object` when calling `create_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_contact_input_object' in params:
            body_params = params['create_contact_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/normalized', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_contact_note(self, create_contact_note_input_object, id, **kwargs):  # noqa: E501
        """Create a new contact note  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_note(create_contact_note_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateContactNoteInputObject create_contact_note_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_contact_note_with_http_info(create_contact_note_input_object, id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_contact_note_with_http_info(create_contact_note_input_object, id, **kwargs)  # noqa: E501
            return data

    def create_contact_note_with_http_info(self, create_contact_note_input_object, id, **kwargs):  # noqa: E501
        """Create a new contact note  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_note_with_http_info(create_contact_note_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateContactNoteInputObject create_contact_note_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['create_contact_note_input_object', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'create_contact_note_input_object' is set
        if ('create_contact_note_input_object' not in params or
                params['create_contact_note_input_object'] is None):
            raise ValueError("Missing the required parameter `create_contact_note_input_object` when calling `create_contact_note`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_contact_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_contact_note_input_object' in params:
            body_params = params['create_contact_note_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/{id}/notes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_custom_field(self, create_custom_field_input_object, **kwargs):  # noqa: E501
        """Add a new custom field  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_custom_field(create_custom_field_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateCustomFieldInputObject create_custom_field_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_custom_field_with_http_info(create_custom_field_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.create_custom_field_with_http_info(create_custom_field_input_object, **kwargs)  # noqa: E501
            return data

    def create_custom_field_with_http_info(self, create_custom_field_input_object, **kwargs):  # noqa: E501
        """Add a new custom field  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_custom_field_with_http_info(create_custom_field_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateCustomFieldInputObject create_custom_field_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['create_custom_field_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'create_custom_field_input_object' is set
        if ('create_custom_field_input_object' not in params or
                params['create_custom_field_input_object'] is None):
            raise ValueError("Missing the required parameter `create_custom_field_input_object` when calling `create_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_custom_field_input_object' in params:
            body_params = params['create_custom_field_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/customfields', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_list(self, create_list_input_object, **kwargs):  # noqa: E501
        """Create a new list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_list(create_list_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateListInputObject create_list_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_list_with_http_info(create_list_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.create_list_with_http_info(create_list_input_object, **kwargs)  # noqa: E501
            return data

    def create_list_with_http_info(self, create_list_input_object, **kwargs):  # noqa: E501
        """Create a new list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_list_with_http_info(create_list_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateListInputObject create_list_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['create_list_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'create_list_input_object' is set
        if ('create_list_input_object' not in params or
                params['create_list_input_object'] is None):
            raise ValueError("Missing the required parameter `create_list_input_object` when calling `create_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_list_input_object' in params:
            body_params = params['create_list_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_template(self, create_template_input_object, **kwargs):  # noqa: E501
        """Create a template  # noqa: E501

        There are times when creating a new template makes sense (such as when targeting specific clients or improving your business strategies).  You can create new SMS templates for marketing purposes or SMS templates for business campaigns.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_template(create_template_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateTemplateInputObject create_template_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_template_with_http_info(create_template_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.create_template_with_http_info(create_template_input_object, **kwargs)  # noqa: E501
            return data

    def create_template_with_http_info(self, create_template_input_object, **kwargs):  # noqa: E501
        """Create a template  # noqa: E501

        There are times when creating a new template makes sense (such as when targeting specific clients or improving your business strategies).  You can create new SMS templates for marketing purposes or SMS templates for business campaigns.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_template_with_http_info(create_template_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateTemplateInputObject create_template_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['create_template_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'create_template_input_object' is set
        if ('create_template_input_object' not in params or
                params['create_template_input_object'] is None):
            raise ValueError("Missing the required parameter `create_template_input_object` when calling `create_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'create_template_input_object' in params:
            body_params = params['create_template_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/templates', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_all_contacts(self, **kwargs):  # noqa: E501
        """Delete contacts (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_all_contacts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_all_contacts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_all_contacts_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_all_contacts_with_http_info(self, **kwargs):  # noqa: E501
        """Delete contacts (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_all_contacts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_all_contacts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contact/all', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_all_outbound_messages(self, **kwargs):  # noqa: E501
        """Delete all messages  # noqa: E501

        Delete all messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_all_outbound_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_all_outbound_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_all_outbound_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_all_outbound_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Delete all messages  # noqa: E501

        Delete all messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_all_outbound_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_all_outbound_messages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/message/all', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_avatar(self, **kwargs):  # noqa: E501
        """Delete an avatar  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_avatar(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_avatar_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.delete_avatar_with_http_info(**kwargs)  # noqa: E501
            return data

    def delete_avatar_with_http_info(self, **kwargs):  # noqa: E501
        """Delete an avatar  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_avatar_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_avatar" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user/avatar', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_chat_messages(self, delete_chat_messages_bulk_input_object, id, **kwargs):  # noqa: E501
        """Delete chat messages by ID(s)  # noqa: E501

        Delete messages from chat by given message IDs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_chat_messages(delete_chat_messages_bulk_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteChatMessagesBulkInputObject delete_chat_messages_bulk_input_object: (required)
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_chat_messages_with_http_info(delete_chat_messages_bulk_input_object, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_chat_messages_with_http_info(delete_chat_messages_bulk_input_object, id, **kwargs)  # noqa: E501
            return data

    def delete_chat_messages_with_http_info(self, delete_chat_messages_bulk_input_object, id, **kwargs):  # noqa: E501
        """Delete chat messages by ID(s)  # noqa: E501

        Delete messages from chat by given message IDs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_chat_messages_with_http_info(delete_chat_messages_bulk_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteChatMessagesBulkInputObject delete_chat_messages_bulk_input_object: (required)
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_chat_messages_bulk_input_object', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_chat_messages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_chat_messages_bulk_input_object' is set
        if ('delete_chat_messages_bulk_input_object' not in params or
                params['delete_chat_messages_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_chat_messages_bulk_input_object` when calling `delete_chat_messages`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_chat_messages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_chat_messages_bulk_input_object' in params:
            body_params = params['delete_chat_messages_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/{id}/messages/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_chats_bulk(self, delete_chats_bulk_input_object, **kwargs):  # noqa: E501
        """Delete chats (bulk)  # noqa: E501

        Delete chats by given IDs or delete all chats.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_chats_bulk(delete_chats_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteChatsBulkInputObject delete_chats_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_chats_bulk_with_http_info(delete_chats_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_chats_bulk_with_http_info(delete_chats_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def delete_chats_bulk_with_http_info(self, delete_chats_bulk_input_object, **kwargs):  # noqa: E501
        """Delete chats (bulk)  # noqa: E501

        Delete chats by given IDs or delete all chats.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_chats_bulk_with_http_info(delete_chats_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteChatsBulkInputObject delete_chats_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_chats_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_chats_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_chats_bulk_input_object' is set
        if ('delete_chats_bulk_input_object' not in params or
                params['delete_chats_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_chats_bulk_input_object` when calling `delete_chats_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_chats_bulk_input_object' in params:
            body_params = params['delete_chats_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_contact(self, id, **kwargs):  # noqa: E501
        """Delete a contact  # noqa: E501

        > This command removes your contact completely. If it was assigned or saved to a shared list, it will disappear from there too. If you only need to remove a contact from selected lists, instead use the Contact assignment command in the Lists section rather than deleting the contact.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_contact_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_contact_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_contact_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a contact  # noqa: E501

        > This command removes your contact completely. If it was assigned or saved to a shared list, it will disappear from there too. If you only need to remove a contact from selected lists, instead use the Contact assignment command in the Lists section rather than deleting the contact.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_contact_avatar(self, id, **kwargs):  # noqa: E501
        """Delete an avatar  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_avatar(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_contact_avatar_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_contact_avatar_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_contact_avatar_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete an avatar  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_avatar_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contact_avatar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_contact_avatar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/{id}/avatar', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_contact_note(self, id, **kwargs):  # noqa: E501
        """Delete a contact note  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_note(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_contact_note_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_contact_note_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_contact_note_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a contact note  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_note_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contact_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_contact_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/notes/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_contact_notes_bulk(self, id, delete_contact_notes_bulk_input_object, **kwargs):  # noqa: E501
        """Delete contact notes (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_notes_bulk(id, delete_contact_notes_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DeleteContactNotesBulkInputObject delete_contact_notes_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_contact_notes_bulk_with_http_info(id, delete_contact_notes_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_contact_notes_bulk_with_http_info(id, delete_contact_notes_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def delete_contact_notes_bulk_with_http_info(self, id, delete_contact_notes_bulk_input_object, **kwargs):  # noqa: E501
        """Delete contact notes (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_notes_bulk_with_http_info(id, delete_contact_notes_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param DeleteContactNotesBulkInputObject delete_contact_notes_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'delete_contact_notes_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contact_notes_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_contact_notes_bulk`")  # noqa: E501
        # verify the required parameter 'delete_contact_notes_bulk_input_object' is set
        if ('delete_contact_notes_bulk_input_object' not in params or
                params['delete_contact_notes_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_contact_notes_bulk_input_object` when calling `delete_contact_notes_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_contact_notes_bulk_input_object' in params:
            body_params = params['delete_contact_notes_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/{id}/notes/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_contacts_by_ids(self, delete_contacts_by_ids_input_object, **kwargs):  # noqa: E501
        """Delete contacts by IDs (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contacts_by_ids(delete_contacts_by_ids_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteContactsByIdsInputObject delete_contacts_by_ids_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_contacts_by_ids_with_http_info(delete_contacts_by_ids_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_contacts_by_ids_with_http_info(delete_contacts_by_ids_input_object, **kwargs)  # noqa: E501
            return data

    def delete_contacts_by_ids_with_http_info(self, delete_contacts_by_ids_input_object, **kwargs):  # noqa: E501
        """Delete contacts by IDs (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contacts_by_ids_with_http_info(delete_contacts_by_ids_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteContactsByIdsInputObject delete_contacts_by_ids_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_contacts_by_ids_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contacts_by_ids" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_contacts_by_ids_input_object' is set
        if ('delete_contacts_by_ids_input_object' not in params or
                params['delete_contacts_by_ids_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_contacts_by_ids_input_object` when calling `delete_contacts_by_ids`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_contacts_by_ids_input_object' in params:
            body_params = params['delete_contacts_by_ids_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_contacts_from_list(self, delete_contacs_from_list_object, id, **kwargs):  # noqa: E501
        """Unassign contacts from a list  # noqa: E501

        > When you remove contacts from a specific list, they will be deleted permanently, unless they are first saved in another list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contacts_from_list(delete_contacs_from_list_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteContacsFromListObject delete_contacs_from_list_object: (required)
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_contacts_from_list_with_http_info(delete_contacs_from_list_object, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_contacts_from_list_with_http_info(delete_contacs_from_list_object, id, **kwargs)  # noqa: E501
            return data

    def delete_contacts_from_list_with_http_info(self, delete_contacs_from_list_object, id, **kwargs):  # noqa: E501
        """Unassign contacts from a list  # noqa: E501

        > When you remove contacts from a specific list, they will be deleted permanently, unless they are first saved in another list.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contacts_from_list_with_http_info(delete_contacs_from_list_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteContacsFromListObject delete_contacs_from_list_object: (required)
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_contacs_from_list_object', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contacts_from_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_contacs_from_list_object' is set
        if ('delete_contacs_from_list_object' not in params or
                params['delete_contacs_from_list_object'] is None):
            raise ValueError("Missing the required parameter `delete_contacs_from_list_object` when calling `delete_contacts_from_list`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_contacts_from_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_contacs_from_list_object' in params:
            body_params = params['delete_contacs_from_list_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/{id}/contacts', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_custom_field(self, id, **kwargs):  # noqa: E501
        """Delete a custom field  # noqa: E501

        > When a custom field is deleted, all the information that was added to contacts under this custom field will also be lost.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_custom_field(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_custom_field_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_custom_field_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_custom_field_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a custom field  # noqa: E501

        > When a custom field is deleted, all the information that was added to contacts under this custom field will also be lost.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_custom_field_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/customfields/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dedicated_number(self, id, **kwargs):  # noqa: E501
        """Cancel dedicated number subscription  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dedicated_number(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_dedicated_number_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_dedicated_number_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_dedicated_number_with_http_info(self, id, **kwargs):  # noqa: E501
        """Cancel dedicated number subscription  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dedicated_number_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dedicated_number" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_dedicated_number`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/numbers/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_inbound_message(self, id, **kwargs):  # noqa: E501
        """Delete a single inbound message  # noqa: E501

        > Note, deleted inbound message will disappear from TextMagic Online, chats, and any other place they are referenced.  So, be careful!   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_inbound_message(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The unique numeric ID for the inbound message. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_inbound_message_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_inbound_message_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_inbound_message_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a single inbound message  # noqa: E501

        > Note, deleted inbound message will disappear from TextMagic Online, chats, and any other place they are referenced.  So, be careful!   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_inbound_message_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The unique numeric ID for the inbound message. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_inbound_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_inbound_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/replies/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_inbound_messages_bulk(self, delete_inbound_messages_bulk_input_object, **kwargs):  # noqa: E501
        """Delete inbound messages (bulk)  # noqa: E501

        > Note, deleted inbound message will disappear from TextMagic Online, chats, and any other place they are referenced.  So, be careful!   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_inbound_messages_bulk(delete_inbound_messages_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteInboundMessagesBulkInputObject delete_inbound_messages_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_inbound_messages_bulk_with_http_info(delete_inbound_messages_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_inbound_messages_bulk_with_http_info(delete_inbound_messages_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def delete_inbound_messages_bulk_with_http_info(self, delete_inbound_messages_bulk_input_object, **kwargs):  # noqa: E501
        """Delete inbound messages (bulk)  # noqa: E501

        > Note, deleted inbound message will disappear from TextMagic Online, chats, and any other place they are referenced.  So, be careful!   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_inbound_messages_bulk_with_http_info(delete_inbound_messages_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteInboundMessagesBulkInputObject delete_inbound_messages_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_inbound_messages_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_inbound_messages_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_inbound_messages_bulk_input_object' is set
        if ('delete_inbound_messages_bulk_input_object' not in params or
                params['delete_inbound_messages_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_inbound_messages_bulk_input_object` when calling `delete_inbound_messages_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_inbound_messages_bulk_input_object' in params:
            body_params = params['delete_inbound_messages_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/replies/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_list(self, id, **kwargs):  # noqa: E501
        """Delete a list  # noqa: E501

        This command has no parameters. If successful, this command will return the standard delete response (204 No Content), otherwise a standard error response will be returned.  When you delete a list, the contacts in it are deleted as well unless they were savedin other list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a list  # noqa: E501

        This command has no parameters. If successful, this command will return the standard delete response (204 No Content), otherwise a standard error response will be returned.  When you delete a list, the contacts in it are deleted as well unless they were savedin other list.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_list_avatar(self, id, **kwargs):  # noqa: E501
        """Delete an avatar for the list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_avatar(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_list_avatar_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_list_avatar_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_list_avatar_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete an avatar for the list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_avatar_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_list_avatar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_list_avatar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/{id}/avatar', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_list_contacts_bulk(self, delete_list_contacts_bulk_input_object, id, **kwargs):  # noqa: E501
        """Delete contacts from list (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_contacts_bulk(delete_list_contacts_bulk_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteListContactsBulkInputObject delete_list_contacts_bulk_input_object: (required)
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_list_contacts_bulk_with_http_info(delete_list_contacts_bulk_input_object, id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_list_contacts_bulk_with_http_info(delete_list_contacts_bulk_input_object, id, **kwargs)  # noqa: E501
            return data

    def delete_list_contacts_bulk_with_http_info(self, delete_list_contacts_bulk_input_object, id, **kwargs):  # noqa: E501
        """Delete contacts from list (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_list_contacts_bulk_with_http_info(delete_list_contacts_bulk_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteListContactsBulkInputObject delete_list_contacts_bulk_input_object: (required)
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_list_contacts_bulk_input_object', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_list_contacts_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_list_contacts_bulk_input_object' is set
        if ('delete_list_contacts_bulk_input_object' not in params or
                params['delete_list_contacts_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_list_contacts_bulk_input_object` when calling `delete_list_contacts_bulk`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_list_contacts_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_list_contacts_bulk_input_object' in params:
            body_params = params['delete_list_contacts_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/{id}/contacts/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_lists_bulk(self, delete_lists_bulk_input_object, **kwargs):  # noqa: E501
        """Delete lists (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_lists_bulk(delete_lists_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteListsBulkInputObject delete_lists_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_lists_bulk_with_http_info(delete_lists_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_lists_bulk_with_http_info(delete_lists_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def delete_lists_bulk_with_http_info(self, delete_lists_bulk_input_object, **kwargs):  # noqa: E501
        """Delete lists (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_lists_bulk_with_http_info(delete_lists_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteListsBulkInputObject delete_lists_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_lists_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_lists_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_lists_bulk_input_object' is set
        if ('delete_lists_bulk_input_object' not in params or
                params['delete_lists_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_lists_bulk_input_object` when calling `delete_lists_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_lists_bulk_input_object' in params:
            body_params = params['delete_lists_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_message_session(self, id, **kwargs):  # noqa: E501
        """Delete a session  # noqa: E501

        Delete a message session, together with all nested messages. > You will not be refunded for any deleted sent sessions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_message_session(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_message_session_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_message_session_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_message_session_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a session  # noqa: E501

        Delete a message session, together with all nested messages. > You will not be refunded for any deleted sent sessions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_message_session_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_message_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_message_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_message_sessions_bulk(self, delete_message_sessions_bulk_input_object, **kwargs):  # noqa: E501
        """Delete sessions (bulk)  # noqa: E501

        Delete message sessions, together with all nested messages, by given ID(s) or delete all message sessions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_message_sessions_bulk(delete_message_sessions_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteMessageSessionsBulkInputObject delete_message_sessions_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_message_sessions_bulk_with_http_info(delete_message_sessions_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_message_sessions_bulk_with_http_info(delete_message_sessions_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def delete_message_sessions_bulk_with_http_info(self, delete_message_sessions_bulk_input_object, **kwargs):  # noqa: E501
        """Delete sessions (bulk)  # noqa: E501

        Delete message sessions, together with all nested messages, by given ID(s) or delete all message sessions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_message_sessions_bulk_with_http_info(delete_message_sessions_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteMessageSessionsBulkInputObject delete_message_sessions_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_message_sessions_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_message_sessions_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_message_sessions_bulk_input_object' is set
        if ('delete_message_sessions_bulk_input_object' not in params or
                params['delete_message_sessions_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_message_sessions_bulk_input_object` when calling `delete_message_sessions_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_message_sessions_bulk_input_object' in params:
            body_params = params['delete_message_sessions_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_outbound_message(self, id, **kwargs):  # noqa: E501
        """Delete message  # noqa: E501

        Delete a single message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_outbound_message(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_outbound_message_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_outbound_message_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_outbound_message_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete message  # noqa: E501

        Delete a single message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_outbound_message_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_outbound_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_outbound_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_outbound_messages_bulk(self, delete_outbound_messages_bulk_input_object, **kwargs):  # noqa: E501
        """Delete messages (bulk)  # noqa: E501

        Delete outbound messages by the given ID(s) or delete all outbound messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_outbound_messages_bulk(delete_outbound_messages_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteOutboundMessagesBulkInputObject delete_outbound_messages_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_outbound_messages_bulk_with_http_info(delete_outbound_messages_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_outbound_messages_bulk_with_http_info(delete_outbound_messages_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def delete_outbound_messages_bulk_with_http_info(self, delete_outbound_messages_bulk_input_object, **kwargs):  # noqa: E501
        """Delete messages (bulk)  # noqa: E501

        Delete outbound messages by the given ID(s) or delete all outbound messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_outbound_messages_bulk_with_http_info(delete_outbound_messages_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteOutboundMessagesBulkInputObject delete_outbound_messages_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_outbound_messages_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_outbound_messages_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_outbound_messages_bulk_input_object' is set
        if ('delete_outbound_messages_bulk_input_object' not in params or
                params['delete_outbound_messages_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_outbound_messages_bulk_input_object` when calling `delete_outbound_messages_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_outbound_messages_bulk_input_object' in params:
            body_params = params['delete_outbound_messages_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_scheduled_message(self, id, **kwargs):  # noqa: E501
        """Delete a single scheduled message  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_scheduled_message(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_scheduled_message_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_scheduled_message_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_scheduled_message_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a single scheduled message  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_scheduled_message_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_scheduled_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_scheduled_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/schedules/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_scheduled_messages_bulk(self, delete_scheduled_messages_bulk_input_object, **kwargs):  # noqa: E501
        """Delete scheduled messages (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_scheduled_messages_bulk(delete_scheduled_messages_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteScheduledMessagesBulkInputObject delete_scheduled_messages_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_scheduled_messages_bulk_with_http_info(delete_scheduled_messages_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_scheduled_messages_bulk_with_http_info(delete_scheduled_messages_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def delete_scheduled_messages_bulk_with_http_info(self, delete_scheduled_messages_bulk_input_object, **kwargs):  # noqa: E501
        """Delete scheduled messages (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_scheduled_messages_bulk_with_http_info(delete_scheduled_messages_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteScheduledMessagesBulkInputObject delete_scheduled_messages_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_scheduled_messages_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_scheduled_messages_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_scheduled_messages_bulk_input_object' is set
        if ('delete_scheduled_messages_bulk_input_object' not in params or
                params['delete_scheduled_messages_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_scheduled_messages_bulk_input_object` when calling `delete_scheduled_messages_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_scheduled_messages_bulk_input_object' in params:
            body_params = params['delete_scheduled_messages_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/schedules/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_sender_id(self, id, **kwargs):  # noqa: E501
        """Delete a Sender ID  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_sender_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_sender_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_sender_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_sender_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a Sender ID  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_sender_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_sender_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_sender_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/senderids/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_template(self, id, **kwargs):  # noqa: E501
        """Delete a template  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_template(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_template_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_template_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_template_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete a template  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_template_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/templates/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_templates_bulk(self, delete_templates_bulk_input_object, **kwargs):  # noqa: E501
        """Delete templates (bulk)  # noqa: E501

        Delete templates by given IDs or delete all templates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_templates_bulk(delete_templates_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteTemplatesBulkInputObject delete_templates_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_templates_bulk_with_http_info(delete_templates_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_templates_bulk_with_http_info(delete_templates_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def delete_templates_bulk_with_http_info(self, delete_templates_bulk_input_object, **kwargs):  # noqa: E501
        """Delete templates (bulk)  # noqa: E501

        Delete templates by given IDs or delete all templates.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_templates_bulk_with_http_info(delete_templates_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeleteTemplatesBulkInputObject delete_templates_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['delete_templates_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_templates_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'delete_templates_bulk_input_object' is set
        if ('delete_templates_bulk_input_object' not in params or
                params['delete_templates_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `delete_templates_bulk_input_object` when calling `delete_templates_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'delete_templates_bulk_input_object' in params:
            body_params = params['delete_templates_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/templates/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def do_carrier_lookup(self, phone, **kwargs):  # noqa: E501
        """Carrier Lookup  # noqa: E501

        This API call allows you to retrieve additional information about a phone number: region-specific phone number formatting, carrier, phone type (landline/mobile) and country information.  > Numbers can be checked one by one. You cannot check multiple numbers in one request.     # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.do_carrier_lookup(phone, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str phone: Phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164) or in [National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers).  (required)
        :param str country: This option must be specified only if the phone number in a **[National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers)**. 
        :return: DoCarrierLookupResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.do_carrier_lookup_with_http_info(phone, **kwargs)  # noqa: E501
        else:
            (data) = self.do_carrier_lookup_with_http_info(phone, **kwargs)  # noqa: E501
            return data

    def do_carrier_lookup_with_http_info(self, phone, **kwargs):  # noqa: E501
        """Carrier Lookup  # noqa: E501

        This API call allows you to retrieve additional information about a phone number: region-specific phone number formatting, carrier, phone type (landline/mobile) and country information.  > Numbers can be checked one by one. You cannot check multiple numbers in one request.     # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.do_carrier_lookup_with_http_info(phone, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str phone: Phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164) or in [National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers).  (required)
        :param str country: This option must be specified only if the phone number in a **[National format](https://en.wikipedia.org/wiki/National_conventions_for_writing_telephone_numbers)**. 
        :return: DoCarrierLookupResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['phone', 'country']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method do_carrier_lookup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'phone' is set
        if ('phone' not in params or
                params['phone'] is None):
            raise ValueError("Missing the required parameter `phone` when calling `do_carrier_lookup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'phone' in params:
            path_params['phone'] = params['phone']  # noqa: E501

        query_params = []
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lookups/{phone}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DoCarrierLookupResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def do_email_lookup(self, email, **kwargs):  # noqa: E501
        """Email Lookup  # noqa: E501

        To get more details about an email address or to check if it is a valid email, you can use the Email Lookup command. To upload and check emails in bulk, please use our [Web app](https://my.textmagic.com/online/email-lookup/).  This API call allows you to retrieve additional information about an email address, such as mailbox detection, syntax checks, DNS validation, deliverability status, and many more helpful values (see the table below).  > Emails must be checked one by one. You cannot check multiple emails in one request.To upload and check emails in bulk, please use our [Web app](https://my.textmagic.com/online/email-lookup/).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.do_email_lookup(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email: Email address. (required)
        :return: DoEmailLookupResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.do_email_lookup_with_http_info(email, **kwargs)  # noqa: E501
        else:
            (data) = self.do_email_lookup_with_http_info(email, **kwargs)  # noqa: E501
            return data

    def do_email_lookup_with_http_info(self, email, **kwargs):  # noqa: E501
        """Email Lookup  # noqa: E501

        To get more details about an email address or to check if it is a valid email, you can use the Email Lookup command. To upload and check emails in bulk, please use our [Web app](https://my.textmagic.com/online/email-lookup/).  This API call allows you to retrieve additional information about an email address, such as mailbox detection, syntax checks, DNS validation, deliverability status, and many more helpful values (see the table below).  > Emails must be checked one by one. You cannot check multiple emails in one request.To upload and check emails in bulk, please use our [Web app](https://my.textmagic.com/online/email-lookup/).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.do_email_lookup_with_http_info(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email: Email address. (required)
        :return: DoEmailLookupResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method do_email_lookup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `do_email_lookup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/email-lookups/{email}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DoEmailLookupResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_bulk_sessions(self, **kwargs):  # noqa: E501
        """Get all bulk sessions  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_bulk_sessions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetAllBulkSessionsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_bulk_sessions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_bulk_sessions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_bulk_sessions_with_http_info(self, **kwargs):  # noqa: E501
        """Get all bulk sessions  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_bulk_sessions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetAllBulkSessionsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_bulk_sessions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bulks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllBulkSessionsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_chats(self, **kwargs):  # noqa: E501
        """Get all chats  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_chats(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str status: Fetch only (a)ctive, (c)losed or (d)eleted chats
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str order_by: Order results by some field. Default is id
        :param int voice: Fetch results with voice calls
        :param int flat: Should additional contact info be included
        :return: GetAllChatsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_chats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_chats_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_chats_with_http_info(self, **kwargs):  # noqa: E501
        """Get all chats  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_chats_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str status: Fetch only (a)ctive, (c)losed or (d)eleted chats
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str order_by: Order results by some field. Default is id
        :param int voice: Fetch results with voice calls
        :param int flat: Should additional contact info be included
        :return: GetAllChatsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['status', 'page', 'limit', 'order_by', 'voice', 'flat']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_chats" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'voice' in params:
            query_params.append(('voice', params['voice']))  # noqa: E501
        if 'flat' in params:
            query_params.append(('flat', params['flat']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllChatsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_inbound_messages(self, **kwargs):  # noqa: E501
        """Get all inbound messages  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_inbound_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: GetAllInboundMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_inbound_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_inbound_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_inbound_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Get all inbound messages  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_inbound_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: GetAllInboundMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'order_by', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_inbound_messages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/replies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllInboundMessagesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_message_sessions(self, **kwargs):  # noqa: E501
        """Get all sessions  # noqa: E501

        Get all message sending sessions. > This list contains all of your sessions, including those which were sent but not via API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_message_sessions(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetAllMessageSessionsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_message_sessions_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_message_sessions_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_message_sessions_with_http_info(self, **kwargs):  # noqa: E501
        """Get all sessions  # noqa: E501

        Get all message sending sessions. > This list contains all of your sessions, including those which were sent but not via API   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_message_sessions_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetAllMessageSessionsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_message_sessions" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllMessageSessionsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_outbound_messages(self, **kwargs):  # noqa: E501
        """Get all messages  # noqa: E501

        Get all user oubound messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_outbound_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID. Note that the \\'page\\' parameter is ignored when \\'lastId\\' is specified
        :return: GetAllOutboundMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_outbound_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_outbound_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_outbound_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Get all messages  # noqa: E501

        Get all user oubound messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_outbound_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID. Note that the \\'page\\' parameter is ignored when \\'lastId\\' is specified
        :return: GetAllOutboundMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'last_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_outbound_messages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'last_id' in params:
            query_params.append(('lastId', params['last_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllOutboundMessagesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_scheduled_messages(self, **kwargs):  # noqa: E501
        """Get all scheduled messages  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_scheduled_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str status: Fetch schedules with the specific status: a - actual, c - completed, x - all
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: GetAllScheduledMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_scheduled_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_scheduled_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_scheduled_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Get all scheduled messages  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_scheduled_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str status: Fetch schedules with the specific status: a - actual, c - completed, x - all
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: GetAllScheduledMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'status', 'order_by', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_scheduled_messages" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/schedules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllScheduledMessagesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_templates(self, **kwargs):  # noqa: E501
        """Get all templates  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_templates(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetAllTemplatesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_templates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_templates_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_templates_with_http_info(self, **kwargs):  # noqa: E501
        """Get all templates  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_templates_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetAllTemplatesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_templates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/templates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAllTemplatesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_available_dedicated_numbers(self, country, **kwargs):  # noqa: E501
        """Find dedicated numbers available for purchase  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_available_dedicated_numbers(country, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str country: Two-letter dedicated number country ISO code. (required)
        :param int prefix: Desired number prefix. Should include country code (i.e. 447 for UK phone number format). Leave blank to get all the available numbers for the specified country.
        :param int tollfree: Should we show only tollfree numbers (tollfree available only for US).
        :return: GetAvailableDedicatedNumbersResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_available_dedicated_numbers_with_http_info(country, **kwargs)  # noqa: E501
        else:
            (data) = self.get_available_dedicated_numbers_with_http_info(country, **kwargs)  # noqa: E501
            return data

    def get_available_dedicated_numbers_with_http_info(self, country, **kwargs):  # noqa: E501
        """Find dedicated numbers available for purchase  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_available_dedicated_numbers_with_http_info(country, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str country: Two-letter dedicated number country ISO code. (required)
        :param int prefix: Desired number prefix. Should include country code (i.e. 447 for UK phone number format). Leave blank to get all the available numbers for the specified country.
        :param int tollfree: Should we show only tollfree numbers (tollfree available only for US).
        :return: GetAvailableDedicatedNumbersResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['country', 'prefix', 'tollfree']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_available_dedicated_numbers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'country' is set
        if ('country' not in params or
                params['country'] is None):
            raise ValueError("Missing the required parameter `country` when calling `get_available_dedicated_numbers`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'prefix' in params:
            query_params.append(('prefix', params['prefix']))  # noqa: E501
        if 'tollfree' in params:
            query_params.append(('tollfree', params['tollfree']))  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/numbers/available', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAvailableDedicatedNumbersResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_available_sender_setting_options(self, **kwargs):  # noqa: E501
        """Get available sender settings  # noqa: E501

        Get all available sender setting options which could be used in \"from\" parameter of POST messages method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_available_sender_setting_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str country: The 2-letter ISO country ID. If not specified, it returns all the available sender settings.
        :return: GetAvailableSenderSettingOptionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_available_sender_setting_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_available_sender_setting_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_available_sender_setting_options_with_http_info(self, **kwargs):  # noqa: E501
        """Get available sender settings  # noqa: E501

        Get all available sender setting options which could be used in \"from\" parameter of POST messages method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_available_sender_setting_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str country: The 2-letter ISO country ID. If not specified, it returns all the available sender settings.
        :return: GetAvailableSenderSettingOptionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['country']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_available_sender_setting_options" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAvailableSenderSettingOptionsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_balance_notification_options(self, **kwargs):  # noqa: E501
        """Returns the list of available balance options which can be used as a bound to determine when to send email to user with low balance notification. See https://my.textmagic.com/online/account/notifications/balance  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_balance_notification_options(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetBalanceNotificationOptionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_balance_notification_options_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_balance_notification_options_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_balance_notification_options_with_http_info(self, **kwargs):  # noqa: E501
        """Returns the list of available balance options which can be used as a bound to determine when to send email to user with low balance notification. See https://my.textmagic.com/online/account/notifications/balance  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_balance_notification_options_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetBalanceNotificationOptionsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_balance_notification_options" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user/notification/balance/bundles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetBalanceNotificationOptionsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_balance_notification_settings(self, **kwargs):  # noqa: E501
        """Get balance notification settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_balance_notification_settings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetBalanceNotificationSettingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_balance_notification_settings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_balance_notification_settings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_balance_notification_settings_with_http_info(self, **kwargs):  # noqa: E501
        """Get balance notification settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_balance_notification_settings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetBalanceNotificationSettingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_balance_notification_settings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user/notification/balance', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetBalanceNotificationSettingsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_blocked_contacts(self, **kwargs):  # noqa: E501
        """Get blocked contacts  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_blocked_contacts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find blocked contacts by specified search query.
        :param str order_by: Order results by some field. Default is id.
        :param str direction: Order direction. Default is desc.
        :return: GetBlockedContactsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_blocked_contacts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_blocked_contacts_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_blocked_contacts_with_http_info(self, **kwargs):  # noqa: E501
        """Get blocked contacts  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_blocked_contacts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find blocked contacts by specified search query.
        :param str order_by: Order results by some field. Default is id.
        :param str direction: Order direction. Default is desc.
        :return: GetBlockedContactsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'query', 'order_by', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_blocked_contacts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/block/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetBlockedContactsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bulk_session(self, id, **kwargs):  # noqa: E501
        """Get bulk session status  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_session(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: BulkSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bulk_session_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bulk_session_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_bulk_session_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get bulk session status  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bulk_session_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: BulkSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bulk_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_bulk_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bulks/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BulkSession',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_callback_settings(self, **kwargs):  # noqa: E501
        """Fetch callback URL settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callback_settings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetCallbackSettingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_callback_settings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_callback_settings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_callback_settings_with_http_info(self, **kwargs):  # noqa: E501
        """Fetch callback URL settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callback_settings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetCallbackSettingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_callback_settings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/callback/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetCallbackSettingsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_chat(self, id, **kwargs):  # noqa: E501
        """Get a single chat  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_chat(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: Chat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_chat_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_chat_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_chat_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a single chat  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_chat_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: Chat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_chat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_chat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Chat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_chat_by_phone(self, phone, **kwargs):  # noqa: E501
        """Find chats by phone  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_chat_by_phone(phone, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str phone: (required)
        :param int upsert: Create a new chat if not found
        :param int reopen: Reopen chat if found or do not change status
        :return: Chat
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_chat_by_phone_with_http_info(phone, **kwargs)  # noqa: E501
        else:
            (data) = self.get_chat_by_phone_with_http_info(phone, **kwargs)  # noqa: E501
            return data

    def get_chat_by_phone_with_http_info(self, phone, **kwargs):  # noqa: E501
        """Find chats by phone  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_chat_by_phone_with_http_info(phone, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str phone: (required)
        :param int upsert: Create a new chat if not found
        :param int reopen: Reopen chat if found or do not change status
        :return: Chat
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['phone', 'upsert', 'reopen']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_chat_by_phone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'phone' is set
        if ('phone' not in params or
                params['phone'] is None):
            raise ValueError("Missing the required parameter `phone` when calling `get_chat_by_phone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'phone' in params:
            path_params['phone'] = params['phone']  # noqa: E501

        query_params = []
        if 'upsert' in params:
            query_params.append(('upsert', params['upsert']))  # noqa: E501
        if 'reopen' in params:
            query_params.append(('reopen', params['reopen']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/{phone}/by/phone', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Chat',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_chat_messages(self, id, **kwargs):  # noqa: E501
        """Get chat messages  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_chat_messages(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find messages by specified search query
        :param int start: Return messages since specified timestamp only
        :param int end: Return messages up to specified timestamp only
        :param str direction: Order direction. Default is desc.
        :param int voice: Fetch results with voice calls
        :return: GetChatMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_chat_messages_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_chat_messages_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_chat_messages_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get chat messages  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_chat_messages_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find messages by specified search query
        :param int start: Return messages since specified timestamp only
        :param int end: Return messages up to specified timestamp only
        :param str direction: Order direction. Default is desc.
        :param int voice: Fetch results with voice calls
        :return: GetChatMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'page', 'limit', 'query', 'start', 'end', 'direction', 'voice']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_chat_messages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_chat_messages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501
        if 'voice' in params:
            query_params.append(('voice', params['voice']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/{id}/message', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetChatMessagesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific contact  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The contact id (required)
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_contact_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_contact_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_contact_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific contact  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The contact id (required)
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_by_phone(self, phone, **kwargs):  # noqa: E501
        """Get the details of a specific contact by phone number  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_by_phone(phone, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str phone: (required)
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_contact_by_phone_with_http_info(phone, **kwargs)  # noqa: E501
        else:
            (data) = self.get_contact_by_phone_with_http_info(phone, **kwargs)  # noqa: E501
            return data

    def get_contact_by_phone_with_http_info(self, phone, **kwargs):  # noqa: E501
        """Get the details of a specific contact by phone number  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_by_phone_with_http_info(phone, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str phone: (required)
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['phone']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_by_phone" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'phone' is set
        if ('phone' not in params or
                params['phone'] is None):
            raise ValueError("Missing the required parameter `phone` when calling `get_contact_by_phone`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'phone' in params:
            path_params['phone'] = params['phone']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/phone/{phone}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_if_blocked(self, phone, **kwargs):  # noqa: E501
        """Check is that phone number blocked  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_if_blocked(phone, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str phone: Phone number to check (required)
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_contact_if_blocked_with_http_info(phone, **kwargs)  # noqa: E501
        else:
            (data) = self.get_contact_if_blocked_with_http_info(phone, **kwargs)  # noqa: E501
            return data

    def get_contact_if_blocked_with_http_info(self, phone, **kwargs):  # noqa: E501
        """Check is that phone number blocked  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_if_blocked_with_http_info(phone, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str phone: Phone number to check (required)
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['phone']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_if_blocked" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'phone' is set
        if ('phone' not in params or
                params['phone'] is None):
            raise ValueError("Missing the required parameter `phone` when calling `get_contact_if_blocked`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'phone' in params:
            query_params.append(('phone', params['phone']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/block/phone', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_import_session_progress(self, id, **kwargs):  # noqa: E501
        """Check import progress  # noqa: E501

        Get contact import session progress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_import_session_progress(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: GetContactImportSessionProgressResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_contact_import_session_progress_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_contact_import_session_progress_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_contact_import_session_progress_with_http_info(self, id, **kwargs):  # noqa: E501
        """Check import progress  # noqa: E501

        Get contact import session progress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_import_session_progress_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: GetContactImportSessionProgressResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_import_session_progress" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_contact_import_session_progress`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/import/progress/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetContactImportSessionProgressResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_note(self, id, **kwargs):  # noqa: E501
        """Get a contact note  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_note(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ContactNote
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_contact_note_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_contact_note_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_contact_note_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a contact note  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_note_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: ContactNote
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_contact_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/notes/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactNote',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contact_notes(self, id, **kwargs):  # noqa: E501
        """Fetch notes assigned to the given contact.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_notes(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetContactNotesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_contact_notes_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_contact_notes_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_contact_notes_with_http_info(self, id, **kwargs):  # noqa: E501
        """Fetch notes assigned to the given contact.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contact_notes_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetContactNotesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'page', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contact_notes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_contact_notes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/{id}/notes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetContactNotesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contacts(self, **kwargs):  # noqa: E501
        """Get all contacts  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contacts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param int shared: Should shared contacts to be included
        :param str order_by: Order results by some field. Default is id.
        :param str direction: Order direction. Default is desc.
        :return: GetContactsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_contacts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_contacts_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_contacts_with_http_info(self, **kwargs):  # noqa: E501
        """Get all contacts  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contacts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param int shared: Should shared contacts to be included
        :param str order_by: Order results by some field. Default is id.
        :param str direction: Order direction. Default is desc.
        :return: GetContactsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'shared', 'order_by', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contacts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'shared' in params:
            query_params.append(('shared', params['shared']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetContactsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contacts_autocomplete(self, query, **kwargs):  # noqa: E501
        """Get contacts autocomplete suggestions  # noqa: E501

        Get contacts autocomplete suggestions by given search term  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contacts_autocomplete(query, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: Find recipients by specified search query. (required)
        :param int limit: The number of results per page.
        :param int lists: Should lists be returned or not
        :return: GetContactsAutocompleteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_contacts_autocomplete_with_http_info(query, **kwargs)  # noqa: E501
        else:
            (data) = self.get_contacts_autocomplete_with_http_info(query, **kwargs)  # noqa: E501
            return data

    def get_contacts_autocomplete_with_http_info(self, query, **kwargs):  # noqa: E501
        """Get contacts autocomplete suggestions  # noqa: E501

        Get contacts autocomplete suggestions by given search term  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contacts_autocomplete_with_http_info(query, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: Find recipients by specified search query. (required)
        :param int limit: The number of results per page.
        :param int lists: Should lists be returned or not
        :return: GetContactsAutocompleteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query', 'limit', 'lists']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contacts_autocomplete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query' is set
        if ('query' not in params or
                params['query'] is None):
            raise ValueError("Missing the required parameter `query` when calling `get_contacts_autocomplete`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'lists' in params:
            query_params.append(('lists', params['lists']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/autocomplete', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetContactsAutocompleteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contacts_by_list_id(self, id, **kwargs):  # noqa: E501
        """Get all contacts in a list  # noqa: E501

        A useful synonym for \"contacts/search\" command with provided \"listId\" parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contacts_by_list_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Given group Id. (required)
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: GetContactsByListIdPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_contacts_by_list_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_contacts_by_list_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_contacts_by_list_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get all contacts in a list  # noqa: E501

        A useful synonym for \"contacts/search\" command with provided \"listId\" parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contacts_by_list_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Given group Id. (required)
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: GetContactsByListIdPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'page', 'limit', 'order_by', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contacts_by_list_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_contacts_by_list_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/{id}/contacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetContactsByListIdPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_countries(self, **kwargs):  # noqa: E501
        """Get countries  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_countries(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetCountriesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_countries_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_countries_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_countries_with_http_info(self, **kwargs):  # noqa: E501
        """Get countries  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_countries_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetCountriesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_countries" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/countries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetCountriesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_current_user(self, **kwargs):  # noqa: E501
        """Get current account information  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_user(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_current_user_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_current_user_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_current_user_with_http_info(self, **kwargs):  # noqa: E501
        """Get current account information  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_user_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_user" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_custom_field(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific custom field  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_field(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: UserCustomField
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_custom_field_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_custom_field_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_custom_field_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific custom field  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_field_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: UserCustomField
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/customfields/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserCustomField',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_custom_fields(self, **kwargs):  # noqa: E501
        """Get all custom fields  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_fields(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetCustomFieldsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_custom_fields_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_custom_fields_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_custom_fields_with_http_info(self, **kwargs):  # noqa: E501
        """Get all custom fields  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_custom_fields_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetCustomFieldsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_custom_fields" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/customfields', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetCustomFieldsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dedicated_number(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific dedicated number  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dedicated_number(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: UsersInbound
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dedicated_number_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dedicated_number_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_dedicated_number_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific dedicated number  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dedicated_number_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: UsersInbound
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dedicated_number" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_dedicated_number`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/numbers/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsersInbound',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_favourites(self, **kwargs):  # noqa: E501
        """Get favorite contacts and lists  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_favourites(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find contacts or lists by specified search query
        :return: GetFavouritesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_favourites_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_favourites_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_favourites_with_http_info(self, **kwargs):  # noqa: E501
        """Get favorite contacts and lists  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_favourites_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find contacts or lists by specified search query
        :return: GetFavouritesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'query']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_favourites" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/favorite', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetFavouritesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_inbound_message(self, id, **kwargs):  # noqa: E501
        """Get a single inbound message  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_inbound_message(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The unique numeric ID for the inbound message. (required)
        :return: MessageIn
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_inbound_message_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_inbound_message_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_inbound_message_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a single inbound message  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_inbound_message_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The unique numeric ID for the inbound message. (required)
        :return: MessageIn
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_inbound_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_inbound_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/replies/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageIn',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_inbound_messages_notification_settings(self, **kwargs):  # noqa: E501
        """Get inbound messages notification settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_inbound_messages_notification_settings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetInboundMessagesNotificationSettingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_inbound_messages_notification_settings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_inbound_messages_notification_settings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_inbound_messages_notification_settings_with_http_info(self, **kwargs):  # noqa: E501
        """Get inbound messages notification settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_inbound_messages_notification_settings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetInboundMessagesNotificationSettingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_inbound_messages_notification_settings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user/notification/inbound', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInboundMessagesNotificationSettingsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_invoices(self, **kwargs):  # noqa: E501
        """Get all invoices  # noqa: E501

        With the TextMagic API, you can check the invoices and transactions for your account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoices(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetInvoicesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_invoices_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_invoices_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_invoices_with_http_info(self, **kwargs):  # noqa: E501
        """Get all invoices  # noqa: E501

        With the TextMagic API, you can check the invoices and transactions for your account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_invoices_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetInvoicesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_invoices" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/invoices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetInvoicesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_list(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: List
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: List
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='List',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_list_contacts_ids(self, id, **kwargs):  # noqa: E501
        """Get all contacts IDs in a list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_contacts_ids(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: GetListContactsIdsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_list_contacts_ids_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_list_contacts_ids_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_list_contacts_ids_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get all contacts IDs in a list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_list_contacts_ids_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: GetListContactsIdsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_list_contacts_ids" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_list_contacts_ids`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/{id}/contacts/ids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetListContactsIdsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lists(self, **kwargs):  # noqa: E501
        """Get all lists  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lists(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The current fetched page.
        :param int limit: The number of results per page.
        :param str order_by: Order results by some field. Default is id.
        :param str direction: Order direction. Default is desc.
        :param int favorite_only: Return only favorited lists.
        :param int only_mine: Return only current user lists.
        :return: GetListsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_lists_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_lists_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_lists_with_http_info(self, **kwargs):  # noqa: E501
        """Get all lists  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lists_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: The current fetched page.
        :param int limit: The number of results per page.
        :param str order_by: Order results by some field. Default is id.
        :param str direction: Order direction. Default is desc.
        :param int favorite_only: Return only favorited lists.
        :param int only_mine: Return only current user lists.
        :return: GetListsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'order_by', 'direction', 'favorite_only', 'only_mine']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lists" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501
        if 'favorite_only' in params:
            query_params.append(('favoriteOnly', params['favorite_only']))  # noqa: E501
        if 'only_mine' in params:
            query_params.append(('onlyMine', params['only_mine']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetListsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_lists_of_contact(self, id, **kwargs):  # noqa: E501
        """Get contact's lists  # noqa: E501

        Get all the lists in which the contact is included  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lists_of_contact(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetListsOfContactPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_lists_of_contact_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_lists_of_contact_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_lists_of_contact_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get contact's lists  # noqa: E501

        Get all the lists in which the contact is included  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_lists_of_contact_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetListsOfContactPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'page', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_lists_of_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_lists_of_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/{id}/lists', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetListsOfContactPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_message_preview(self, **kwargs):  # noqa: E501
        """Preview message  # noqa: E501

        Get a messages preview (with tags merged) of up to 100 messages per session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_preview(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str text: Message text. Required if **template_id** is not set.
        :param int template_id: Template used instead of message text. Required if **text** is not set.
        :param int sending_time: DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time is in unix timestamp format. Default is now.
        :param str sending_date_time: Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone.
        :param str sending_timezone: The ID or ISO-name of the timezone used for sending when the sendingDateTime parameter is set, e.g. if you specify sendingDateTime = \\\"2016-05-27 13:02:33\\\" and sendingTimezone = \\\"America/Buenos_Aires\\\", your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone.
        :param str contacts: Comma-separated array of contact resources id message will be sent to.
        :param str lists: Comma-separated array of list resources id message will be sent to.
        :param str phones: Comma-separated array of E.164 phone numbers message will be sent to.
        :param int cut_extra: Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead.
        :param int parts_count: Maximum message parts count (TextMagic allows sending of 1 to 6 message parts).
        :param int reference_id: Custom message reference id which can be used in your application infrastructure.
        :param str _from: One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](http://docs.textmagictesting.com/#tag/Sender-IDs).
        :param str rule: An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details.
        :param int create_chat: Should the sending method try to create new Chat(if not exist) with specified recipients?
        :param int tts: Send Text-to-Speech message.
        :param int local: Treat phone numbers passed in the \\'phones\\' field as local.
        :param str local_country: The 2-letter ISO country code for local phone numbers, used when \\'local\\' is set to true. Default is the account country.
        :return: GetMessagePreviewResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_message_preview_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_message_preview_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_message_preview_with_http_info(self, **kwargs):  # noqa: E501
        """Preview message  # noqa: E501

        Get a messages preview (with tags merged) of up to 100 messages per session.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_preview_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str text: Message text. Required if **template_id** is not set.
        :param int template_id: Template used instead of message text. Required if **text** is not set.
        :param int sending_time: DEPRECATED, consider using sendingDateTime and sendingTimezone parameters instead: Optional (required with rrule set). Message sending time is in unix timestamp format. Default is now.
        :param str sending_date_time: Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone.
        :param str sending_timezone: The ID or ISO-name of the timezone used for sending when the sendingDateTime parameter is set, e.g. if you specify sendingDateTime = \\\"2016-05-27 13:02:33\\\" and sendingTimezone = \\\"America/Buenos_Aires\\\", your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone.
        :param str contacts: Comma-separated array of contact resources id message will be sent to.
        :param str lists: Comma-separated array of list resources id message will be sent to.
        :param str phones: Comma-separated array of E.164 phone numbers message will be sent to.
        :param int cut_extra: Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead.
        :param int parts_count: Maximum message parts count (TextMagic allows sending of 1 to 6 message parts).
        :param int reference_id: Custom message reference id which can be used in your application infrastructure.
        :param str _from: One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](http://docs.textmagictesting.com/#tag/Sender-IDs).
        :param str rule: An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details.
        :param int create_chat: Should the sending method try to create new Chat(if not exist) with specified recipients?
        :param int tts: Send Text-to-Speech message.
        :param int local: Treat phone numbers passed in the \\'phones\\' field as local.
        :param str local_country: The 2-letter ISO country code for local phone numbers, used when \\'local\\' is set to true. Default is the account country.
        :return: GetMessagePreviewResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['text', 'template_id', 'sending_time', 'sending_date_time', 'sending_timezone', 'contacts', 'lists', 'phones', 'cut_extra', 'parts_count', 'reference_id', '_from', 'rule', 'create_chat', 'tts', 'local', 'local_country']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_message_preview" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'text' in params:
            query_params.append(('text', params['text']))  # noqa: E501
        if 'template_id' in params:
            query_params.append(('templateId', params['template_id']))  # noqa: E501
        if 'sending_time' in params:
            query_params.append(('sendingTime', params['sending_time']))  # noqa: E501
        if 'sending_date_time' in params:
            query_params.append(('sendingDateTime', params['sending_date_time']))  # noqa: E501
        if 'sending_timezone' in params:
            query_params.append(('sendingTimezone', params['sending_timezone']))  # noqa: E501
        if 'contacts' in params:
            query_params.append(('contacts', params['contacts']))  # noqa: E501
        if 'lists' in params:
            query_params.append(('lists', params['lists']))  # noqa: E501
        if 'phones' in params:
            query_params.append(('phones', params['phones']))  # noqa: E501
        if 'cut_extra' in params:
            query_params.append(('cutExtra', params['cut_extra']))  # noqa: E501
        if 'parts_count' in params:
            query_params.append(('partsCount', params['parts_count']))  # noqa: E501
        if 'reference_id' in params:
            query_params.append(('referenceId', params['reference_id']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'rule' in params:
            query_params.append(('rule', params['rule']))  # noqa: E501
        if 'create_chat' in params:
            query_params.append(('createChat', params['create_chat']))  # noqa: E501
        if 'tts' in params:
            query_params.append(('tts', params['tts']))  # noqa: E501
        if 'local' in params:
            query_params.append(('local', params['local']))  # noqa: E501
        if 'local_country' in params:
            query_params.append(('localCountry', params['local_country']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/preview', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMessagePreviewResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_message_price(self, **kwargs):  # noqa: E501
        """Check message price  # noqa: E501

        Check pricing for a new outbound message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_price(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int include_blocked: Should we show the pricing for blocked contacts?
        :param str text: Message text. Required if the **template_id** is not set.
        :param int template_id: Template used instead of message text. Required if the **text** is not set.
        :param int sending_time: DEPRECATED, consider using the sendingDateTime and sendingTimezone parameters instead: optional (required with rrule set). Message sending time is in unix timestamp format. Default is now.
        :param str sending_date_time: Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone.
        :param str sending_timezone: The ID or ISO-name of the timezone used for sending when sendingDateTime parameter is set, e.g. if you specify sendingDateTime = \\\"2016-05-27 13:02:33\\\" and sendingTimezone = \\\"America/Buenos_Aires\\\", your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone.
        :param str contacts: Comma-separated array of contact resources id message will be sent to.
        :param str lists: Comma-separated array of list resources id message will be sent to.
        :param str phones: Comma-separated array of E.164 phone numbers message will be sent to.
        :param int cut_extra: Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead.
        :param int parts_count: Maximum message parts count (TextMagic allows sending 1 to 6 message parts).
        :param int reference_id: Custom message reference id which can be used in your application infrastructure.
        :param str _from: One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](http://docs.textmagictesting.com/#tag/Sender-IDs).
        :param str rule: An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details.
        :param int create_chat: Should the sending method try to create new Chat (if not exist) with specified recipients?
        :param int tts: Send a Text-to-Speech message.
        :param int local: Treat phone numbers passed in the \\'phones\\' field as local.
        :param str local_country: The 2-letter ISO country code for local phone numbers, used when \\'local\\' is set to true. Default is the account country.
        :return: GetMessagePriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_message_price_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_message_price_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_message_price_with_http_info(self, **kwargs):  # noqa: E501
        """Check message price  # noqa: E501

        Check pricing for a new outbound message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_price_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int include_blocked: Should we show the pricing for blocked contacts?
        :param str text: Message text. Required if the **template_id** is not set.
        :param int template_id: Template used instead of message text. Required if the **text** is not set.
        :param int sending_time: DEPRECATED, consider using the sendingDateTime and sendingTimezone parameters instead: optional (required with rrule set). Message sending time is in unix timestamp format. Default is now.
        :param str sending_date_time: Sending time is in Y-m-d H:i:s format (e.g. 2016-05-27 13:02:33). This time is relative to the sendingTimezone.
        :param str sending_timezone: The ID or ISO-name of the timezone used for sending when sendingDateTime parameter is set, e.g. if you specify sendingDateTime = \\\"2016-05-27 13:02:33\\\" and sendingTimezone = \\\"America/Buenos_Aires\\\", your message will be sent on May 27, 2016 13:02:33 Buenos Aires time, or 16:02:33 UTC. Default is the account timezone.
        :param str contacts: Comma-separated array of contact resources id message will be sent to.
        :param str lists: Comma-separated array of list resources id message will be sent to.
        :param str phones: Comma-separated array of E.164 phone numbers message will be sent to.
        :param int cut_extra: Should sending method cut extra characters which not fit supplied partsCount or return 400 Bad request response instead.
        :param int parts_count: Maximum message parts count (TextMagic allows sending 1 to 6 message parts).
        :param int reference_id: Custom message reference id which can be used in your application infrastructure.
        :param str _from: One of the allowed Sender ID (phone number or alphanumeric sender ID). If the specified Sender ID is not allowed for some destinations, a fallback default Sender ID will be used to ensure delivery. See [Get timezones](http://docs.textmagictesting.com/#tag/Sender-IDs).
        :param str rule: An iCal RRULE parameter to create recurrent scheduled messages. When used, sendingTime is mandatory as the start point of sending. See https://www.textmagic.com/free-tools/rrule-generator for format details.
        :param int create_chat: Should the sending method try to create new Chat (if not exist) with specified recipients?
        :param int tts: Send a Text-to-Speech message.
        :param int local: Treat phone numbers passed in the \\'phones\\' field as local.
        :param str local_country: The 2-letter ISO country code for local phone numbers, used when \\'local\\' is set to true. Default is the account country.
        :return: GetMessagePriceResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include_blocked', 'text', 'template_id', 'sending_time', 'sending_date_time', 'sending_timezone', 'contacts', 'lists', 'phones', 'cut_extra', 'parts_count', 'reference_id', '_from', 'rule', 'create_chat', 'tts', 'local', 'local_country']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_message_price" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include_blocked' in params:
            query_params.append(('includeBlocked', params['include_blocked']))  # noqa: E501
        if 'text' in params:
            query_params.append(('text', params['text']))  # noqa: E501
        if 'template_id' in params:
            query_params.append(('templateId', params['template_id']))  # noqa: E501
        if 'sending_time' in params:
            query_params.append(('sendingTime', params['sending_time']))  # noqa: E501
        if 'sending_date_time' in params:
            query_params.append(('sendingDateTime', params['sending_date_time']))  # noqa: E501
        if 'sending_timezone' in params:
            query_params.append(('sendingTimezone', params['sending_timezone']))  # noqa: E501
        if 'contacts' in params:
            query_params.append(('contacts', params['contacts']))  # noqa: E501
        if 'lists' in params:
            query_params.append(('lists', params['lists']))  # noqa: E501
        if 'phones' in params:
            query_params.append(('phones', params['phones']))  # noqa: E501
        if 'cut_extra' in params:
            query_params.append(('cutExtra', params['cut_extra']))  # noqa: E501
        if 'parts_count' in params:
            query_params.append(('partsCount', params['parts_count']))  # noqa: E501
        if 'reference_id' in params:
            query_params.append(('referenceId', params['reference_id']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'rule' in params:
            query_params.append(('rule', params['rule']))  # noqa: E501
        if 'create_chat' in params:
            query_params.append(('createChat', params['create_chat']))  # noqa: E501
        if 'tts' in params:
            query_params.append(('tts', params['tts']))  # noqa: E501
        if 'local' in params:
            query_params.append(('local', params['local']))  # noqa: E501
        if 'local_country' in params:
            query_params.append(('localCountry', params['local_country']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/price/normalized', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMessagePriceResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_message_session(self, id, **kwargs):  # noqa: E501
        """Get a session`s details  # noqa: E501

        Get a specific sessions details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_session(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Session ID. (required)
        :return: MessageSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_message_session_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_message_session_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_message_session_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a session`s details  # noqa: E501

        Get a specific sessions details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_session_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Session ID. (required)
        :return: MessageSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_message_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_message_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageSession',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_message_session_stat(self, id, **kwargs):  # noqa: E501
        """Get a session`s statistics  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_session_stat(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int include_deleted: Search also in deleted messages.
        :return: GetMessageSessionStatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_message_session_stat_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_message_session_stat_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_message_session_stat_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a session`s statistics  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_message_session_stat_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int include_deleted: Search also in deleted messages.
        :return: GetMessageSessionStatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'include_deleted']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_message_session_stat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_message_session_stat`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'include_deleted' in params:
            query_params.append(('includeDeleted', params['include_deleted']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{id}/stat', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMessageSessionStatResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_messages_by_session_id(self, id, **kwargs):  # noqa: E501
        """Get a session`s messages  # noqa: E501

        A useful synonym for the \"messages/search\" command with the provided \"sessionId\" parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_messages_by_session_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str statuses: Find messages by status.
        :param int include_deleted: Search also in deleted messages.
        :return: GetMessagesBySessionIdPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_messages_by_session_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_messages_by_session_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_messages_by_session_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a session`s messages  # noqa: E501

        A useful synonym for the \"messages/search\" command with the provided \"sessionId\" parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_messages_by_session_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str statuses: Find messages by status.
        :param int include_deleted: Search also in deleted messages.
        :return: GetMessagesBySessionIdPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'page', 'limit', 'statuses', 'include_deleted']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_messages_by_session_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_messages_by_session_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
        if 'include_deleted' in params:
            query_params.append(('includeDeleted', params['include_deleted']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sessions/{id}/messages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMessagesBySessionIdPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_messaging_counters(self, **kwargs):  # noqa: E501
        """Get sent/received messages counters values  # noqa: E501

        Get total contacts, sent messages and received messages counters values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_messaging_counters(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetMessagingCountersResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_messaging_counters_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_messaging_counters_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_messaging_counters_with_http_info(self, **kwargs):  # noqa: E501
        """Get sent/received messages counters values  # noqa: E501

        Get total contacts, sent messages and received messages counters values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_messaging_counters_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetMessagingCountersResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_messaging_counters" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/stats/messaging/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMessagingCountersResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_messaging_stat(self, **kwargs):  # noqa: E501
        """Get messaging statistics  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_messaging_stat(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str by: *   **off** to get total values per specified time interval *   **day** to show values grouped by day *   **month** to show values grouped by month *   **year** to show values grouped by year 
        :param int start: Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is 7 days prior. 
        :param int end: Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is today. 
        :return: GetMessagingStatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_messaging_stat_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_messaging_stat_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_messaging_stat_with_http_info(self, **kwargs):  # noqa: E501
        """Get messaging statistics  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_messaging_stat_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str by: *   **off** to get total values per specified time interval *   **day** to show values grouped by day *   **month** to show values grouped by month *   **year** to show values grouped by year 
        :param int start: Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is 7 days prior. 
        :param int end: Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is today. 
        :return: GetMessagingStatResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['by', 'start', 'end']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_messaging_stat" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'by' in params:
            query_params.append(('by', params['by']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/stats/messaging', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMessagingStatResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_outbound_message(self, id, **kwargs):  # noqa: E501
        """Get a single message  # noqa: E501

        Get a single outgoing message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_outbound_message(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: MessageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_outbound_message_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_outbound_message_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_outbound_message_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a single message  # noqa: E501

        Get a single outgoing message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_outbound_message_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: MessageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_outbound_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_outbound_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_outbound_messages_history(self, **kwargs):  # noqa: E501
        """Get history  # noqa: E501

        Get the outbound messages history.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_outbound_messages_history(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: The number of results per page.
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID.
        :param str query: Find message by specified search query
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: GetOutboundMessagesHistoryPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_outbound_messages_history_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_outbound_messages_history_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_outbound_messages_history_with_http_info(self, **kwargs):  # noqa: E501
        """Get history  # noqa: E501

        Get the outbound messages history.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_outbound_messages_history_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int limit: The number of results per page.
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID.
        :param str query: Find message by specified search query
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: GetOutboundMessagesHistoryPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['limit', 'last_id', 'query', 'order_by', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_outbound_messages_history" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'last_id' in params:
            query_params.append(('lastId', params['last_id']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetOutboundMessagesHistoryPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_scheduled_message(self, id, **kwargs):  # noqa: E501
        """Get a single scheduled message  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scheduled_message(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: MessagesIcs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_scheduled_message_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_scheduled_message_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_scheduled_message_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a single scheduled message  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scheduled_message_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: MessagesIcs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scheduled_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_scheduled_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/schedules/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessagesIcs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sender_id(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific Sender ID  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sender_id(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: SenderId
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sender_id_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_sender_id_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_sender_id_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific Sender ID  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sender_id_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: SenderId
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sender_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_sender_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/senderids/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SenderId',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sender_ids(self, **kwargs):  # noqa: E501
        """Get all your approved Sender IDs  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sender_ids(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetSenderIdsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sender_ids_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_sender_ids_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_sender_ids_with_http_info(self, **kwargs):  # noqa: E501
        """Get all your approved Sender IDs  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sender_ids_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetSenderIdsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sender_ids" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/senderids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSenderIdsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_sender_settings(self, **kwargs):  # noqa: E501
        """Get current sender settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sender_settings(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str country: Return sender settings enabled for sending to specified country. Two upper case characters
        :return: GetSenderSettingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_sender_settings_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_sender_settings_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_sender_settings_with_http_info(self, **kwargs):  # noqa: E501
        """Get current sender settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_sender_settings_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str country: Return sender settings enabled for sending to specified country. Two upper case characters
        :return: GetSenderSettingsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['country']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_sender_settings" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sender/settings/normalized', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSenderSettingsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_spending_stat(self, **kwargs):  # noqa: E501
        """Get spending statistics  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_spending_stat(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str start: Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is 7 days prior. 
        :param str end: Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is today. 
        :return: GetSpendingStatPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_spending_stat_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_spending_stat_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_spending_stat_with_http_info(self, **kwargs):  # noqa: E501
        """Get spending statistics  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_spending_stat_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str start: Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is 7 days prior. 
        :param str end: Time period start in [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time) format. The default is today. 
        :return: GetSpendingStatPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'start', 'end']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_spending_stat" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/stats/spending', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSpendingStatPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_subaccount(self, id, **kwargs):  # noqa: E501
        """Get sub-account information  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subaccount(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_subaccount_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subaccount_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_subaccount_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get sub-account information  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subaccount_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subaccount" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_subaccount`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/subaccounts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_subaccounts(self, **kwargs):  # noqa: E501
        """Get sub-accounts list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subaccounts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_subaccounts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_subaccounts_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_subaccounts_with_http_info(self, **kwargs):  # noqa: E501
        """Get sub-accounts list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subaccounts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subaccounts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/subaccounts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_subaccounts_with_tokens(self, get_subaccounts_with_tokens_input_object, **kwargs):  # noqa: E501
        """Get all sub-accounts with their REST API tokens associated with app name  # noqa: E501

        Get all sub-accounts with their REST API tokens associated with specified app name. When more than one token related to app name, last key will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subaccounts_with_tokens(get_subaccounts_with_tokens_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetSubaccountsWithTokensInputObject get_subaccounts_with_tokens_input_object: (required)
        :param float page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetSubaccountsWithTokensResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_subaccounts_with_tokens_with_http_info(get_subaccounts_with_tokens_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.get_subaccounts_with_tokens_with_http_info(get_subaccounts_with_tokens_input_object, **kwargs)  # noqa: E501
            return data

    def get_subaccounts_with_tokens_with_http_info(self, get_subaccounts_with_tokens_input_object, **kwargs):  # noqa: E501
        """Get all sub-accounts with their REST API tokens associated with app name  # noqa: E501

        Get all sub-accounts with their REST API tokens associated with specified app name. When more than one token related to app name, last key will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_subaccounts_with_tokens_with_http_info(get_subaccounts_with_tokens_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetSubaccountsWithTokensInputObject get_subaccounts_with_tokens_input_object: (required)
        :param float page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetSubaccountsWithTokensResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['get_subaccounts_with_tokens_input_object', 'page', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_subaccounts_with_tokens" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'get_subaccounts_with_tokens_input_object' is set
        if ('get_subaccounts_with_tokens_input_object' not in params or
                params['get_subaccounts_with_tokens_input_object'] is None):
            raise ValueError("Missing the required parameter `get_subaccounts_with_tokens_input_object` when calling `get_subaccounts_with_tokens`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'get_subaccounts_with_tokens_input_object' in params:
            body_params = params['get_subaccounts_with_tokens_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/subaccounts/tokens/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetSubaccountsWithTokensResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_template(self, id, **kwargs):  # noqa: E501
        """Get a template`s details  # noqa: E501

        Get a single template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: MessageTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_template_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_template_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_template_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a template`s details  # noqa: E501

        Get a single template.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: MessageTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/templates/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessageTemplate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_timezones(self, **kwargs):  # noqa: E501
        """Get timezones  # noqa: E501

        Return all available timezone IDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_timezones(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int full: Return full info about timezones in array (0 or 1). Default is 0
        :return: GetTimezonesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_timezones_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_timezones_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_timezones_with_http_info(self, **kwargs):  # noqa: E501
        """Get timezones  # noqa: E501

        Return all available timezone IDs  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_timezones_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int full: Return full info about timezones in array (0 or 1). Default is 0
        :return: GetTimezonesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['full']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_timezones" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'full' in params:
            query_params.append(('full', params['full']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/timezones', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetTimezonesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_unread_messages_total(self, **kwargs):  # noqa: E501
        """Get unread messages number  # noqa: E501

        Get total amount of unread messages in the current user chats.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unread_messages_total(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetUnreadMessagesTotalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_unread_messages_total_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_unread_messages_total_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_unread_messages_total_with_http_info(self, **kwargs):  # noqa: E501
        """Get unread messages number  # noqa: E501

        Get total amount of unread messages in the current user chats.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unread_messages_total_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GetUnreadMessagesTotalResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unread_messages_total" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/unread/count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetUnreadMessagesTotalResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_unsubscribed_contact(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific unsubscribed contact  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unsubscribed_contact(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: UnsubscribedContact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_unsubscribed_contact_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_unsubscribed_contact_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_unsubscribed_contact_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the details of a specific unsubscribed contact  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unsubscribed_contact_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :return: UnsubscribedContact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unsubscribed_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_unsubscribed_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/unsubscribers/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UnsubscribedContact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_unsubscribers(self, **kwargs):  # noqa: E501
        """Get all unsubscribed contacts  # noqa: E501

        When one of your message recipients sends a request with one of the [STOP-words](https://www.textmagic.com/sms-stop-command/), they will be immediately opted-out of your send lists and their contact status will change to an unsubscribed contact. To retrieve information on all contacts who have unsubscribed, use:   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unsubscribers(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetUnsubscribersPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_unsubscribers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_unsubscribers_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_unsubscribers_with_http_info(self, **kwargs):  # noqa: E501
        """Get all unsubscribed contacts  # noqa: E501

        When one of your message recipients sends a request with one of the [STOP-words](https://www.textmagic.com/sms-stop-command/), they will be immediately opted-out of your send lists and their contact status will change to an unsubscribed contact. To retrieve information on all contacts who have unsubscribed, use:   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_unsubscribers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :return: GetUnsubscribersPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_unsubscribers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/unsubscribers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetUnsubscribersPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_dedicated_numbers(self, **kwargs):  # noqa: E501
        """Get all your dedicated numbers  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_dedicated_numbers(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param int survey_id: Fetch only that numbers which are ready for the survey
        :return: GetUserDedicatedNumbersPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_dedicated_numbers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_user_dedicated_numbers_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_user_dedicated_numbers_with_http_info(self, **kwargs):  # noqa: E501
        """Get all your dedicated numbers  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_dedicated_numbers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param int survey_id: Fetch only that numbers which are ready for the survey
        :return: GetUserDedicatedNumbersPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'survey_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_dedicated_numbers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'survey_id' in params:
            query_params.append(('surveyId', params['survey_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/numbers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetUserDedicatedNumbersPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_contacts(self, file, column, **kwargs):  # noqa: E501
        """Import contacts  # noqa: E501

        Import contacts from the CSV, XLS or XLSX file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_contacts(file, column, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: File containing contacts in csv or xls(x) formats (required)
        :param str column: Import file column mapping. String must contain substrings of mapping in format `columnNumber:field` glued by `;`. For example: `0:firstName;1:lastName;3:phone;4:email` where value before `:` is a number of column in file, value after `:` is a field of newly created contact or ID of custom field. Numbers of columns begins from zero. Allowed built-in contact fields: `firstName`, `lastName`, `phone`, `email`. Existing of `phone` mapping is required.  (required)
        :param int list_id: List ID contacts will be imported to. Ignored if `listName` is specified. 
        :param str list_name: List name. This list will be created during import. If such name is already taken, an ordinal (1, 2, ...) will be added to the end. Ignored if `listId` is specified. 
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_contacts_with_http_info(file, column, **kwargs)  # noqa: E501
        else:
            (data) = self.import_contacts_with_http_info(file, column, **kwargs)  # noqa: E501
            return data

    def import_contacts_with_http_info(self, file, column, **kwargs):  # noqa: E501
        """Import contacts  # noqa: E501

        Import contacts from the CSV, XLS or XLSX file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_contacts_with_http_info(file, column, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: File containing contacts in csv or xls(x) formats (required)
        :param str column: Import file column mapping. String must contain substrings of mapping in format `columnNumber:field` glued by `;`. For example: `0:firstName;1:lastName;3:phone;4:email` where value before `:` is a number of column in file, value after `:` is a field of newly created contact or ID of custom field. Numbers of columns begins from zero. Allowed built-in contact fields: `firstName`, `lastName`, `phone`, `email`. Existing of `phone` mapping is required.  (required)
        :param int list_id: List ID contacts will be imported to. Ignored if `listName` is specified. 
        :param str list_name: List name. This list will be created during import. If such name is already taken, an ordinal (1, 2, ...) will be added to the end. Ignored if `listId` is specified. 
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'column', 'list_id', 'list_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_contacts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `import_contacts`")  # noqa: E501
        # verify the required parameter 'column' is set
        if ('column' not in params or
                params['column'] is None):
            raise ValueError("Missing the required parameter `column` when calling `import_contacts`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'column' in params:
            query_params.append(('column', params['column']))  # noqa: E501
        if 'list_id' in params:
            query_params.append(('listId', params['list_id']))  # noqa: E501
        if 'list_name' in params:
            query_params.append(('listName', params['list_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/import/normalized', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def invite_subaccount(self, invite_subaccount_input_object, **kwargs):  # noqa: E501
        """Invite a new sub-account  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invite_subaccount(invite_subaccount_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param InviteSubaccountInputObject invite_subaccount_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.invite_subaccount_with_http_info(invite_subaccount_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.invite_subaccount_with_http_info(invite_subaccount_input_object, **kwargs)  # noqa: E501
            return data

    def invite_subaccount_with_http_info(self, invite_subaccount_input_object, **kwargs):  # noqa: E501
        """Invite a new sub-account  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.invite_subaccount_with_http_info(invite_subaccount_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param InviteSubaccountInputObject invite_subaccount_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['invite_subaccount_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method invite_subaccount" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'invite_subaccount_input_object' is set
        if ('invite_subaccount_input_object' not in params or
                params['invite_subaccount_input_object'] is None):
            raise ValueError("Missing the required parameter `invite_subaccount_input_object` when calling `invite_subaccount`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'invite_subaccount_input_object' in params:
            body_params = params['invite_subaccount_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/subaccounts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_chats_read_bulk(self, mark_chats_read_bulk_input_object, **kwargs):  # noqa: E501
        """Mark chats as read (bulk)  # noqa: E501

        Mark several chats as read by chat IDs or mark all chats as read  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_chats_read_bulk(mark_chats_read_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MarkChatsReadBulkInputObject mark_chats_read_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_chats_read_bulk_with_http_info(mark_chats_read_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_chats_read_bulk_with_http_info(mark_chats_read_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def mark_chats_read_bulk_with_http_info(self, mark_chats_read_bulk_input_object, **kwargs):  # noqa: E501
        """Mark chats as read (bulk)  # noqa: E501

        Mark several chats as read by chat IDs or mark all chats as read  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_chats_read_bulk_with_http_info(mark_chats_read_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MarkChatsReadBulkInputObject mark_chats_read_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mark_chats_read_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_chats_read_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mark_chats_read_bulk_input_object' is set
        if ('mark_chats_read_bulk_input_object' not in params or
                params['mark_chats_read_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `mark_chats_read_bulk_input_object` when calling `mark_chats_read_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'mark_chats_read_bulk_input_object' in params:
            body_params = params['mark_chats_read_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/read/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mark_chats_unread_bulk(self, mark_chats_unread_bulk_input_object, **kwargs):  # noqa: E501
        """Mark chats as unread (bulk)  # noqa: E501

        Mark several chats as UNread by chat IDs or mark all chats as UNread  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_chats_unread_bulk(mark_chats_unread_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MarkChatsUnreadBulkInputObject mark_chats_unread_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mark_chats_unread_bulk_with_http_info(mark_chats_unread_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.mark_chats_unread_bulk_with_http_info(mark_chats_unread_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def mark_chats_unread_bulk_with_http_info(self, mark_chats_unread_bulk_input_object, **kwargs):  # noqa: E501
        """Mark chats as unread (bulk)  # noqa: E501

        Mark several chats as UNread by chat IDs or mark all chats as UNread  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mark_chats_unread_bulk_with_http_info(mark_chats_unread_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MarkChatsUnreadBulkInputObject mark_chats_unread_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mark_chats_unread_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mark_chats_unread_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mark_chats_unread_bulk_input_object' is set
        if ('mark_chats_unread_bulk_input_object' not in params or
                params['mark_chats_unread_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `mark_chats_unread_bulk_input_object` when calling `mark_chats_unread_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'mark_chats_unread_bulk_input_object' in params:
            body_params = params['mark_chats_unread_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/unread/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mute_chat(self, mute_chat_input_object, **kwargs):  # noqa: E501
        """Mute chat sounds  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mute_chat(mute_chat_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MuteChatInputObject mute_chat_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mute_chat_with_http_info(mute_chat_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.mute_chat_with_http_info(mute_chat_input_object, **kwargs)  # noqa: E501
            return data

    def mute_chat_with_http_info(self, mute_chat_input_object, **kwargs):  # noqa: E501
        """Mute chat sounds  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mute_chat_with_http_info(mute_chat_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MuteChatInputObject mute_chat_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mute_chat_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mute_chat" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mute_chat_input_object' is set
        if ('mute_chat_input_object' not in params or
                params['mute_chat_input_object'] is None):
            raise ValueError("Missing the required parameter `mute_chat_input_object` when calling `mute_chat`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'mute_chat_input_object' in params:
            body_params = params['mute_chat_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/mute', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mute_chats_bulk(self, mute_chats_bulk_input_object, **kwargs):  # noqa: E501
        """Mute chats (bulk)  # noqa: E501

        Mute several chats by chat IDs or mute all chats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mute_chats_bulk(mute_chats_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MuteChatsBulkInputObject mute_chats_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.mute_chats_bulk_with_http_info(mute_chats_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.mute_chats_bulk_with_http_info(mute_chats_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def mute_chats_bulk_with_http_info(self, mute_chats_bulk_input_object, **kwargs):  # noqa: E501
        """Mute chats (bulk)  # noqa: E501

        Mute several chats by chat IDs or mute all chats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mute_chats_bulk_with_http_info(mute_chats_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MuteChatsBulkInputObject mute_chats_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['mute_chats_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mute_chats_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'mute_chats_bulk_input_object' is set
        if ('mute_chats_bulk_input_object' not in params or
                params['mute_chats_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `mute_chats_bulk_input_object` when calling `mute_chats_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'mute_chats_bulk_input_object' in params:
            body_params = params['mute_chats_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/mute/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ping(self, **kwargs):  # noqa: E501
        """Ping  # noqa: E501

        Make a simple ping request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ping(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: PingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ping_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ping_with_http_info(**kwargs)  # noqa: E501
            return data

    def ping_with_http_info(self, **kwargs):  # noqa: E501
        """Ping  # noqa: E501

        Make a simple ping request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ping_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: PingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ping" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/ping', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reopen_chats_bulk(self, reopen_chats_bulk_input_object, **kwargs):  # noqa: E501
        """Reopen chats (bulk)  # noqa: E501

        Reopen chats by chat IDs or reopen all chats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reopen_chats_bulk(reopen_chats_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReopenChatsBulkInputObject reopen_chats_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reopen_chats_bulk_with_http_info(reopen_chats_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.reopen_chats_bulk_with_http_info(reopen_chats_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def reopen_chats_bulk_with_http_info(self, reopen_chats_bulk_input_object, **kwargs):  # noqa: E501
        """Reopen chats (bulk)  # noqa: E501

        Reopen chats by chat IDs or reopen all chats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reopen_chats_bulk_with_http_info(reopen_chats_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReopenChatsBulkInputObject reopen_chats_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reopen_chats_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reopen_chats_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'reopen_chats_bulk_input_object' is set
        if ('reopen_chats_bulk_input_object' not in params or
                params['reopen_chats_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `reopen_chats_bulk_input_object` when calling `reopen_chats_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'reopen_chats_bulk_input_object' in params:
            body_params = params['reopen_chats_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/reopen/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def request_new_subaccount_token(self, request_new_subaccount_token_input_object, **kwargs):  # noqa: E501
        """Request a new REST API token for sub-account  # noqa: E501

        Returning user object, key and app name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_new_subaccount_token(request_new_subaccount_token_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RequestNewSubaccountTokenInputObject request_new_subaccount_token_input_object: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.request_new_subaccount_token_with_http_info(request_new_subaccount_token_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.request_new_subaccount_token_with_http_info(request_new_subaccount_token_input_object, **kwargs)  # noqa: E501
            return data

    def request_new_subaccount_token_with_http_info(self, request_new_subaccount_token_input_object, **kwargs):  # noqa: E501
        """Request a new REST API token for sub-account  # noqa: E501

        Returning user object, key and app name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_new_subaccount_token_with_http_info(request_new_subaccount_token_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RequestNewSubaccountTokenInputObject request_new_subaccount_token_input_object: (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['request_new_subaccount_token_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_new_subaccount_token" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'request_new_subaccount_token_input_object' is set
        if ('request_new_subaccount_token_input_object' not in params or
                params['request_new_subaccount_token_input_object'] is None):
            raise ValueError("Missing the required parameter `request_new_subaccount_token_input_object` when calling `request_new_subaccount_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request_new_subaccount_token_input_object' in params:
            body_params = params['request_new_subaccount_token_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/subaccounts/tokens', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def request_sender_id(self, request_sender_id_input_object, **kwargs):  # noqa: E501
        """Apply for a new Sender ID  # noqa: E501

        > Sender IDs are shared between all of your sub-accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_sender_id(request_sender_id_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RequestSenderIdInputObject request_sender_id_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.request_sender_id_with_http_info(request_sender_id_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.request_sender_id_with_http_info(request_sender_id_input_object, **kwargs)  # noqa: E501
            return data

    def request_sender_id_with_http_info(self, request_sender_id_input_object, **kwargs):  # noqa: E501
        """Apply for a new Sender ID  # noqa: E501

        > Sender IDs are shared between all of your sub-accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_sender_id_with_http_info(request_sender_id_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RequestSenderIdInputObject request_sender_id_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['request_sender_id_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_sender_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'request_sender_id_input_object' is set
        if ('request_sender_id_input_object' not in params or
                params['request_sender_id_input_object'] is None):
            raise ValueError("Missing the required parameter `request_sender_id_input_object` when calling `request_sender_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request_sender_id_input_object' in params:
            body_params = params['request_sender_id_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/senderids', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_chats(self, **kwargs):  # noqa: E501
        """Find chats by message text  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_chats(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find chats by specified search query
        :return: SearchChatsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_chats_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_chats_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_chats_with_http_info(self, **kwargs):  # noqa: E501
        """Find chats by message text  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_chats_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find chats by specified search query
        :return: SearchChatsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'query']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_chats" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchChatsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_chats_by_ids(self, **kwargs):  # noqa: E501
        """Find chats (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_chats_by_ids(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str ids: Find chats by ID(s)
        :return: SearchChatsByIdsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_chats_by_ids_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_chats_by_ids_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_chats_by_ids_with_http_info(self, **kwargs):  # noqa: E501
        """Find chats (bulk)  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_chats_by_ids_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str ids: Find chats by ID(s)
        :return: SearchChatsByIdsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_chats_by_ids" % key
                )
            params[key] = val
        del params['kwargs']

        if 'ids' in params and not re.search(r'[,\\d]+', params['ids']):  # noqa: E501
            raise ValueError("Invalid value for parameter `ids` when calling `search_chats_by_ids`, must conform to the pattern `/[,\\d]+/`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/search/ids', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchChatsByIdsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_chats_by_receipent(self, **kwargs):  # noqa: E501
        """Find chats by recipient  # noqa: E501

        Find chats by recipient (contact, list name or phone number).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_chats_by_receipent(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find chats by specified search query
        :param str order_by: Order results by some field. Default is id
        :return: SearchChatsByReceipentPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_chats_by_receipent_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_chats_by_receipent_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_chats_by_receipent_with_http_info(self, **kwargs):  # noqa: E501
        """Find chats by recipient  # noqa: E501

        Find chats by recipient (contact, list name or phone number).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_chats_by_receipent_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find chats by specified search query
        :param str order_by: Order results by some field. Default is id
        :return: SearchChatsByReceipentPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'query', 'order_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_chats_by_receipent" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/search/recipients', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchChatsByReceipentPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contacts(self, **kwargs):  # noqa: E501
        """Find contacts by given criteria  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_contacts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param int shared: Should shared contacts to be included
        :param str ids: Find contact by ID(s)
        :param int list_id: Find contact by List ID
        :param int include_blocked: Should blocked contacts to be included
        :param str query: Find contacts by specified search query
        :param int local: Treat phone number passed in 'query' field as local. Default is 0
        :param str country: 2-letter ISO country code for local phone numbers, used when 'local' is set to true. Default is account country
        :param str order_by: Order results by some field. Default is id.
        :param str direction: Order direction. Default is desc.
        :return: SearchContactsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_contacts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contacts_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contacts_with_http_info(self, **kwargs):  # noqa: E501
        """Find contacts by given criteria  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_contacts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param int shared: Should shared contacts to be included
        :param str ids: Find contact by ID(s)
        :param int list_id: Find contact by List ID
        :param int include_blocked: Should blocked contacts to be included
        :param str query: Find contacts by specified search query
        :param int local: Treat phone number passed in 'query' field as local. Default is 0
        :param str country: 2-letter ISO country code for local phone numbers, used when 'local' is set to true. Default is account country
        :param str order_by: Order results by some field. Default is id.
        :param str direction: Order direction. Default is desc.
        :return: SearchContactsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'shared', 'ids', 'list_id', 'include_blocked', 'query', 'local', 'country', 'order_by', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contacts" % key
                )
            params[key] = val
        del params['kwargs']

        if 'ids' in params and not re.search(r'[,\\d]+', params['ids']):  # noqa: E501
            raise ValueError("Invalid value for parameter `ids` when calling `search_contacts`, must conform to the pattern `/[,\\d]+/`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'shared' in params:
            query_params.append(('shared', params['shared']))  # noqa: E501
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
        if 'list_id' in params:
            query_params.append(('listId', params['list_id']))  # noqa: E501
        if 'include_blocked' in params:
            query_params.append(('includeBlocked', params['include_blocked']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'local' in params:
            query_params.append(('local', params['local']))  # noqa: E501
        if 'country' in params:
            query_params.append(('country', params['country']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchContactsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_inbound_messages(self, **kwargs):  # noqa: E501
        """Find inbound messages  # noqa: E501

        Find inbound messages by given parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_inbound_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str ids: Find message by ID(s).
        :param str query: Find recipients by specified search query.
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :param int expand: Expand by adding firstName, lastName and contactId.
        :return: SearchInboundMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_inbound_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_inbound_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_inbound_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Find inbound messages  # noqa: E501

        Find inbound messages by given parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_inbound_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str ids: Find message by ID(s).
        :param str query: Find recipients by specified search query.
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :param int expand: Expand by adding firstName, lastName and contactId.
        :return: SearchInboundMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'ids', 'query', 'order_by', 'direction', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_inbound_messages" % key
                )
            params[key] = val
        del params['kwargs']

        if 'ids' in params and not re.search(r'[,\\d]+', params['ids']):  # noqa: E501
            raise ValueError("Invalid value for parameter `ids` when calling `search_inbound_messages`, must conform to the pattern `/[,\\d]+/`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/replies/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchInboundMessagesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_lists(self, **kwargs):  # noqa: E501
        """Find lists by given criteria  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_lists(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str ids: Find lists by ID(s)
        :param str query: Find lists by specified search query
        :param int only_mine: Return only current user lists
        :param int only_default: Return only default lists
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: SearchListsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_lists_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_lists_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_lists_with_http_info(self, **kwargs):  # noqa: E501
        """Find lists by given criteria  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_lists_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str ids: Find lists by ID(s)
        :param str query: Find lists by specified search query
        :param int only_mine: Return only current user lists
        :param int only_default: Return only default lists
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: SearchListsPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'ids', 'query', 'only_mine', 'only_default', 'order_by', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_lists" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'only_mine' in params:
            query_params.append(('onlyMine', params['only_mine']))  # noqa: E501
        if 'only_default' in params:
            query_params.append(('onlyDefault', params['only_default']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchListsPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_outbound_messages(self, **kwargs):  # noqa: E501
        """Find messages  # noqa: E501

        Find outbound messages by given parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_outbound_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID. Note that the \\'page\\' parameter is ignored when \\'lastId\\' is specified
        :param str ids: Find message by ID(s).
        :param int session_id: Find messages by session ID.
        :param str statuses: Find messages by status.
        :param int include_deleted: Search also in deleted messages.
        :param str query: Find messages by specified search query.
        :return: SearchOutboundMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_outbound_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_outbound_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_outbound_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Find messages  # noqa: E501

        Find outbound messages by given parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_outbound_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param int last_id: Filter results by ID, selecting all values lesser than the specified ID. Note that the \\'page\\' parameter is ignored when \\'lastId\\' is specified
        :param str ids: Find message by ID(s).
        :param int session_id: Find messages by session ID.
        :param str statuses: Find messages by status.
        :param int include_deleted: Search also in deleted messages.
        :param str query: Find messages by specified search query.
        :return: SearchOutboundMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'last_id', 'ids', 'session_id', 'statuses', 'include_deleted', 'query']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_outbound_messages" % key
                )
            params[key] = val
        del params['kwargs']

        if 'ids' in params and not re.search(r'[,\\d]+', params['ids']):  # noqa: E501
            raise ValueError("Invalid value for parameter `ids` when calling `search_outbound_messages`, must conform to the pattern `/[,\\d]+/`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'last_id' in params:
            query_params.append(('lastId', params['last_id']))  # noqa: E501
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
        if 'session_id' in params:
            query_params.append(('sessionId', params['session_id']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
        if 'include_deleted' in params:
            query_params.append(('includeDeleted', params['include_deleted']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchOutboundMessagesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_scheduled_messages(self, **kwargs):  # noqa: E501
        """Find scheduled messages  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_scheduled_messages(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find messages by specified search query
        :param str ids: Find schedules by ID(s)
        :param str status: Fetch schedules with the specific status: a - actual, c - completed, x - all
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: SearchScheduledMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_scheduled_messages_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_scheduled_messages_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_scheduled_messages_with_http_info(self, **kwargs):  # noqa: E501
        """Find scheduled messages  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_scheduled_messages_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str query: Find messages by specified search query
        :param str ids: Find schedules by ID(s)
        :param str status: Fetch schedules with the specific status: a - actual, c - completed, x - all
        :param str order_by: Order results by some field. Default is id
        :param str direction: Order direction. Default is desc.
        :return: SearchScheduledMessagesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'query', 'ids', 'status', 'order_by', 'direction']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_scheduled_messages" % key
                )
            params[key] = val
        del params['kwargs']

        if 'ids' in params and not re.search(r'[,\\d]+', params['ids']):  # noqa: E501
            raise ValueError("Invalid value for parameter `ids` when calling `search_scheduled_messages`, must conform to the pattern `/[,\\d]+/`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('orderBy', params['order_by']))  # noqa: E501
        if 'direction' in params:
            query_params.append(('direction', params['direction']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/schedules/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchScheduledMessagesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_templates(self, **kwargs):  # noqa: E501
        """Find templates by criteria  # noqa: E501

        Find user templates by given parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_templates(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str ids: Find template by ID(s).
        :param str name: Find template by name.
        :param str content: Find template by content.
        :return: SearchTemplatesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_templates_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_templates_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_templates_with_http_info(self, **kwargs):  # noqa: E501
        """Find templates by criteria  # noqa: E501

        Find user templates by given parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_templates_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Fetch specified results page.
        :param int limit: The number of results per page.
        :param str ids: Find template by ID(s).
        :param str name: Find template by name.
        :param str content: Find template by content.
        :return: SearchTemplatesPaginatedResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'limit', 'ids', 'name', 'content']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_templates" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'content' in params:
            query_params.append(('content', params['content']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/templates/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SearchTemplatesPaginatedResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def send_message(self, send_message_input_object, **kwargs):  # noqa: E501
        """Send message  # noqa: E501

        This is the main entrypoint to send messages. See the examples above for the reference.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_message(send_message_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SendMessageInputObject send_message_input_object: (required)
        :return: SendMessageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.send_message_with_http_info(send_message_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.send_message_with_http_info(send_message_input_object, **kwargs)  # noqa: E501
            return data

    def send_message_with_http_info(self, send_message_input_object, **kwargs):  # noqa: E501
        """Send message  # noqa: E501

        This is the main entrypoint to send messages. See the examples above for the reference.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_message_with_http_info(send_message_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SendMessageInputObject send_message_input_object: (required)
        :return: SendMessageResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['send_message_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_message" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'send_message_input_object' is set
        if ('send_message_input_object' not in params or
                params['send_message_input_object'] is None):
            raise ValueError("Missing the required parameter `send_message_input_object` when calling `send_message`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'send_message_input_object' in params:
            body_params = params['send_message_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SendMessageResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def send_phone_verification_code_tfa(self, send_phone_verification_code_input_object, **kwargs):  # noqa: E501
        """Step 1: Send a verification code   # noqa: E501

        Sends verification code to specified phone number.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_phone_verification_code_tfa(send_phone_verification_code_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SendPhoneVerificationCodeInputObject send_phone_verification_code_input_object: (required)
        :return: SendPhoneVerificationCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.send_phone_verification_code_tfa_with_http_info(send_phone_verification_code_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.send_phone_verification_code_tfa_with_http_info(send_phone_verification_code_input_object, **kwargs)  # noqa: E501
            return data

    def send_phone_verification_code_tfa_with_http_info(self, send_phone_verification_code_input_object, **kwargs):  # noqa: E501
        """Step 1: Send a verification code   # noqa: E501

        Sends verification code to specified phone number.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.send_phone_verification_code_tfa_with_http_info(send_phone_verification_code_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SendPhoneVerificationCodeInputObject send_phone_verification_code_input_object: (required)
        :return: SendPhoneVerificationCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['send_phone_verification_code_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_phone_verification_code_tfa" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'send_phone_verification_code_input_object' is set
        if ('send_phone_verification_code_input_object' not in params or
                params['send_phone_verification_code_input_object'] is None):
            raise ValueError("Missing the required parameter `send_phone_verification_code_input_object` when calling `send_phone_verification_code_tfa`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'send_phone_verification_code_input_object' in params:
            body_params = params['send_phone_verification_code_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/verify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SendPhoneVerificationCodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_chat_status(self, set_chat_status_input_object, **kwargs):  # noqa: E501
        """Change chat status  # noqa: E501

        Set status of the chat given by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_chat_status(set_chat_status_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetChatStatusInputObject set_chat_status_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_chat_status_with_http_info(set_chat_status_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.set_chat_status_with_http_info(set_chat_status_input_object, **kwargs)  # noqa: E501
            return data

    def set_chat_status_with_http_info(self, set_chat_status_input_object, **kwargs):  # noqa: E501
        """Change chat status  # noqa: E501

        Set status of the chat given by ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_chat_status_with_http_info(set_chat_status_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SetChatStatusInputObject set_chat_status_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['set_chat_status_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_chat_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'set_chat_status_input_object' is set
        if ('set_chat_status_input_object' not in params or
                params['set_chat_status_input_object'] is None):
            raise ValueError("Missing the required parameter `set_chat_status_input_object` when calling `set_chat_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'set_chat_status_input_object' in params:
            body_params = params['set_chat_status_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/status', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unblock_contact(self, unblock_contact_input_object, **kwargs):  # noqa: E501
        """Unblock contact by phone number.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unblock_contact(unblock_contact_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UnblockContactInputObject unblock_contact_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unblock_contact_with_http_info(unblock_contact_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.unblock_contact_with_http_info(unblock_contact_input_object, **kwargs)  # noqa: E501
            return data

    def unblock_contact_with_http_info(self, unblock_contact_input_object, **kwargs):  # noqa: E501
        """Unblock contact by phone number.  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unblock_contact_with_http_info(unblock_contact_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UnblockContactInputObject unblock_contact_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['unblock_contact_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unblock_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'unblock_contact_input_object' is set
        if ('unblock_contact_input_object' not in params or
                params['unblock_contact_input_object'] is None):
            raise ValueError("Missing the required parameter `unblock_contact_input_object` when calling `unblock_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unblock_contact_input_object' in params:
            body_params = params['unblock_contact_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/unblock', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unblock_contacts_bulk(self, unblock_contacts_bulk_input_object, **kwargs):  # noqa: E501
        """Unblock contacts (bulk)  # noqa: E501

        Unblock several contacts by blocked contact ids or unblock all contacts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unblock_contacts_bulk(unblock_contacts_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UnblockContactsBulkInputObject unblock_contacts_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unblock_contacts_bulk_with_http_info(unblock_contacts_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.unblock_contacts_bulk_with_http_info(unblock_contacts_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def unblock_contacts_bulk_with_http_info(self, unblock_contacts_bulk_input_object, **kwargs):  # noqa: E501
        """Unblock contacts (bulk)  # noqa: E501

        Unblock several contacts by blocked contact ids or unblock all contacts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unblock_contacts_bulk_with_http_info(unblock_contacts_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UnblockContactsBulkInputObject unblock_contacts_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['unblock_contacts_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unblock_contacts_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'unblock_contacts_bulk_input_object' is set
        if ('unblock_contacts_bulk_input_object' not in params or
                params['unblock_contacts_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `unblock_contacts_bulk_input_object` when calling `unblock_contacts_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unblock_contacts_bulk_input_object' in params:
            body_params = params['unblock_contacts_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/unblock/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unmute_chats_bulk(self, unmute_chats_bulk_input_object, **kwargs):  # noqa: E501
        """Unmute chats (bulk)  # noqa: E501

        Unmute several chats by chat IDs or unmute all chats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unmute_chats_bulk(unmute_chats_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UnmuteChatsBulkInputObject unmute_chats_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unmute_chats_bulk_with_http_info(unmute_chats_bulk_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.unmute_chats_bulk_with_http_info(unmute_chats_bulk_input_object, **kwargs)  # noqa: E501
            return data

    def unmute_chats_bulk_with_http_info(self, unmute_chats_bulk_input_object, **kwargs):  # noqa: E501
        """Unmute chats (bulk)  # noqa: E501

        Unmute several chats by chat IDs or unmute all chats  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unmute_chats_bulk_with_http_info(unmute_chats_bulk_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UnmuteChatsBulkInputObject unmute_chats_bulk_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['unmute_chats_bulk_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unmute_chats_bulk" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'unmute_chats_bulk_input_object' is set
        if ('unmute_chats_bulk_input_object' not in params or
                params['unmute_chats_bulk_input_object'] is None):
            raise ValueError("Missing the required parameter `unmute_chats_bulk_input_object` when calling `unmute_chats_bulk`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unmute_chats_bulk_input_object' in params:
            body_params = params['unmute_chats_bulk_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/chats/unmute/bulk', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unsubscribe_contact(self, unsubscribe_contact_input_object, **kwargs):  # noqa: E501
        """Manually unsubscribe a contact  # noqa: E501

        > Please note, if you unsubscribe a contact, this action cannot be reversed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unsubscribe_contact(unsubscribe_contact_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UnsubscribeContactInputObject unsubscribe_contact_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unsubscribe_contact_with_http_info(unsubscribe_contact_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.unsubscribe_contact_with_http_info(unsubscribe_contact_input_object, **kwargs)  # noqa: E501
            return data

    def unsubscribe_contact_with_http_info(self, unsubscribe_contact_input_object, **kwargs):  # noqa: E501
        """Manually unsubscribe a contact  # noqa: E501

        > Please note, if you unsubscribe a contact, this action cannot be reversed.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unsubscribe_contact_with_http_info(unsubscribe_contact_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UnsubscribeContactInputObject unsubscribe_contact_input_object: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['unsubscribe_contact_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unsubscribe_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'unsubscribe_contact_input_object' is set
        if ('unsubscribe_contact_input_object' not in params or
                params['unsubscribe_contact_input_object'] is None):
            raise ValueError("Missing the required parameter `unsubscribe_contact_input_object` when calling `unsubscribe_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'unsubscribe_contact_input_object' in params:
            body_params = params['unsubscribe_contact_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/unsubscribers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_balance_notification_settings(self, update_balance_notification_settings_input_object, **kwargs):  # noqa: E501
        """Update balance notification settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_balance_notification_settings(update_balance_notification_settings_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateBalanceNotificationSettingsInputObject update_balance_notification_settings_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_balance_notification_settings_with_http_info(update_balance_notification_settings_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.update_balance_notification_settings_with_http_info(update_balance_notification_settings_input_object, **kwargs)  # noqa: E501
            return data

    def update_balance_notification_settings_with_http_info(self, update_balance_notification_settings_input_object, **kwargs):  # noqa: E501
        """Update balance notification settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_balance_notification_settings_with_http_info(update_balance_notification_settings_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateBalanceNotificationSettingsInputObject update_balance_notification_settings_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_balance_notification_settings_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_balance_notification_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_balance_notification_settings_input_object' is set
        if ('update_balance_notification_settings_input_object' not in params or
                params['update_balance_notification_settings_input_object'] is None):
            raise ValueError("Missing the required parameter `update_balance_notification_settings_input_object` when calling `update_balance_notification_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_balance_notification_settings_input_object' in params:
            body_params = params['update_balance_notification_settings_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user/notification/balance', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_callback_settings(self, update_callback_settings_input_object, **kwargs):  # noqa: E501
        """Update callback URL settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_callback_settings(update_callback_settings_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCallbackSettingsInputObject update_callback_settings_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_callback_settings_with_http_info(update_callback_settings_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.update_callback_settings_with_http_info(update_callback_settings_input_object, **kwargs)  # noqa: E501
            return data

    def update_callback_settings_with_http_info(self, update_callback_settings_input_object, **kwargs):  # noqa: E501
        """Update callback URL settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_callback_settings_with_http_info(update_callback_settings_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCallbackSettingsInputObject update_callback_settings_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_callback_settings_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_callback_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_callback_settings_input_object' is set
        if ('update_callback_settings_input_object' not in params or
                params['update_callback_settings_input_object'] is None):
            raise ValueError("Missing the required parameter `update_callback_settings_input_object` when calling `update_callback_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_callback_settings_input_object' in params:
            body_params = params['update_callback_settings_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/callback/settings', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_chat_desktop_notification_settings(self, update_chat_desktop_notification_settings_input_object, **kwargs):  # noqa: E501
        """Update chat desktop notification settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_chat_desktop_notification_settings(update_chat_desktop_notification_settings_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateChatDesktopNotificationSettingsInputObject update_chat_desktop_notification_settings_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_chat_desktop_notification_settings_with_http_info(update_chat_desktop_notification_settings_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.update_chat_desktop_notification_settings_with_http_info(update_chat_desktop_notification_settings_input_object, **kwargs)  # noqa: E501
            return data

    def update_chat_desktop_notification_settings_with_http_info(self, update_chat_desktop_notification_settings_input_object, **kwargs):  # noqa: E501
        """Update chat desktop notification settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_chat_desktop_notification_settings_with_http_info(update_chat_desktop_notification_settings_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateChatDesktopNotificationSettingsInputObject update_chat_desktop_notification_settings_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_chat_desktop_notification_settings_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_chat_desktop_notification_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_chat_desktop_notification_settings_input_object' is set
        if ('update_chat_desktop_notification_settings_input_object' not in params or
                params['update_chat_desktop_notification_settings_input_object'] is None):
            raise ValueError("Missing the required parameter `update_chat_desktop_notification_settings_input_object` when calling `update_chat_desktop_notification_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_chat_desktop_notification_settings_input_object' in params:
            body_params = params['update_chat_desktop_notification_settings_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user/desktop/notification', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contact(self, update_contact_input_object, id, **kwargs):  # noqa: E501
        """Edit a contact  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact(update_contact_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateContactInputObject update_contact_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_contact_with_http_info(update_contact_input_object, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contact_with_http_info(update_contact_input_object, id, **kwargs)  # noqa: E501
            return data

    def update_contact_with_http_info(self, update_contact_input_object, id, **kwargs):  # noqa: E501
        """Edit a contact  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact_with_http_info(update_contact_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateContactInputObject update_contact_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_contact_input_object', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_contact_input_object' is set
        if ('update_contact_input_object' not in params or
                params['update_contact_input_object'] is None):
            raise ValueError("Missing the required parameter `update_contact_input_object` when calling `update_contact`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_contact_input_object' in params:
            body_params = params['update_contact_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/{id}/normalized', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contact_note(self, update_contact_note_input_object, id, **kwargs):  # noqa: E501
        """Update a contact note  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact_note(update_contact_note_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateContactNoteInputObject update_contact_note_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_contact_note_with_http_info(update_contact_note_input_object, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contact_note_with_http_info(update_contact_note_input_object, id, **kwargs)  # noqa: E501
            return data

    def update_contact_note_with_http_info(self, update_contact_note_input_object, id, **kwargs):  # noqa: E501
        """Update a contact note  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact_note_with_http_info(update_contact_note_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateContactNoteInputObject update_contact_note_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_contact_note_input_object', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_contact_note_input_object' is set
        if ('update_contact_note_input_object' not in params or
                params['update_contact_note_input_object'] is None):
            raise ValueError("Missing the required parameter `update_contact_note_input_object` when calling `update_contact_note`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_contact_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_contact_note_input_object' in params:
            body_params = params['update_contact_note_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/notes/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_current_user(self, update_current_user_input_object, **kwargs):  # noqa: E501
        """Edit current account info  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_current_user(update_current_user_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCurrentUserInputObject update_current_user_input_object: (required)
        :return: UpdateCurrentUserResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_current_user_with_http_info(update_current_user_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.update_current_user_with_http_info(update_current_user_input_object, **kwargs)  # noqa: E501
            return data

    def update_current_user_with_http_info(self, update_current_user_input_object, **kwargs):  # noqa: E501
        """Edit current account info  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_current_user_with_http_info(update_current_user_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCurrentUserInputObject update_current_user_input_object: (required)
        :return: UpdateCurrentUserResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_current_user_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_current_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_current_user_input_object' is set
        if ('update_current_user_input_object' not in params or
                params['update_current_user_input_object'] is None):
            raise ValueError("Missing the required parameter `update_current_user_input_object` when calling `update_current_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_current_user_input_object' in params:
            body_params = params['update_current_user_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpdateCurrentUserResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_custom_field(self, update_custom_field_input_object, id, **kwargs):  # noqa: E501
        """Edit a custom field  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_custom_field(update_custom_field_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCustomFieldInputObject update_custom_field_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_custom_field_with_http_info(update_custom_field_input_object, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_custom_field_with_http_info(update_custom_field_input_object, id, **kwargs)  # noqa: E501
            return data

    def update_custom_field_with_http_info(self, update_custom_field_input_object, id, **kwargs):  # noqa: E501
        """Edit a custom field  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_custom_field_with_http_info(update_custom_field_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCustomFieldInputObject update_custom_field_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_custom_field_input_object', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_custom_field" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_custom_field_input_object' is set
        if ('update_custom_field_input_object' not in params or
                params['update_custom_field_input_object'] is None):
            raise ValueError("Missing the required parameter `update_custom_field_input_object` when calling `update_custom_field`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_custom_field`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_custom_field_input_object' in params:
            body_params = params['update_custom_field_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/customfields/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_custom_field_value(self, update_custom_field_value_input_object, id, **kwargs):  # noqa: E501
        """Edit the custom field value of a specified contact  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_custom_field_value(update_custom_field_value_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCustomFieldValueInputObject update_custom_field_value_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_custom_field_value_with_http_info(update_custom_field_value_input_object, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_custom_field_value_with_http_info(update_custom_field_value_input_object, id, **kwargs)  # noqa: E501
            return data

    def update_custom_field_value_with_http_info(self, update_custom_field_value_input_object, id, **kwargs):  # noqa: E501
        """Edit the custom field value of a specified contact  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_custom_field_value_with_http_info(update_custom_field_value_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateCustomFieldValueInputObject update_custom_field_value_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_custom_field_value_input_object', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_custom_field_value" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_custom_field_value_input_object' is set
        if ('update_custom_field_value_input_object' not in params or
                params['update_custom_field_value_input_object'] is None):
            raise ValueError("Missing the required parameter `update_custom_field_value_input_object` when calling `update_custom_field_value`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_custom_field_value`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_custom_field_value_input_object' in params:
            body_params = params['update_custom_field_value_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/customfields/{id}/update', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_inbound_messages_notification_settings(self, update_inbound_messages_notification_settings_input_object, **kwargs):  # noqa: E501
        """Update inbound messages notification settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_inbound_messages_notification_settings(update_inbound_messages_notification_settings_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateInboundMessagesNotificationSettingsInputObject update_inbound_messages_notification_settings_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_inbound_messages_notification_settings_with_http_info(update_inbound_messages_notification_settings_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.update_inbound_messages_notification_settings_with_http_info(update_inbound_messages_notification_settings_input_object, **kwargs)  # noqa: E501
            return data

    def update_inbound_messages_notification_settings_with_http_info(self, update_inbound_messages_notification_settings_input_object, **kwargs):  # noqa: E501
        """Update inbound messages notification settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_inbound_messages_notification_settings_with_http_info(update_inbound_messages_notification_settings_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateInboundMessagesNotificationSettingsInputObject update_inbound_messages_notification_settings_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_inbound_messages_notification_settings_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_inbound_messages_notification_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_inbound_messages_notification_settings_input_object' is set
        if ('update_inbound_messages_notification_settings_input_object' not in params or
                params['update_inbound_messages_notification_settings_input_object'] is None):
            raise ValueError("Missing the required parameter `update_inbound_messages_notification_settings_input_object` when calling `update_inbound_messages_notification_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_inbound_messages_notification_settings_input_object' in params:
            body_params = params['update_inbound_messages_notification_settings_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user/notification/inbound', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_list(self, id, **kwargs):  # noqa: E501
        """Edit a list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param UpdateListObject update_list_object:
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """Edit a list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param UpdateListObject update_list_object:
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'update_list_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_list_object' in params:
            body_params = params['update_list_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_sender_setting(self, update_sender_setting_input_object, **kwargs):  # noqa: E501
        """Change sender settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_sender_setting(update_sender_setting_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateSenderSettingInputObject update_sender_setting_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_sender_setting_with_http_info(update_sender_setting_input_object, **kwargs)  # noqa: E501
        else:
            (data) = self.update_sender_setting_with_http_info(update_sender_setting_input_object, **kwargs)  # noqa: E501
            return data

    def update_sender_setting_with_http_info(self, update_sender_setting_input_object, **kwargs):  # noqa: E501
        """Change sender settings  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_sender_setting_with_http_info(update_sender_setting_input_object, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateSenderSettingInputObject update_sender_setting_input_object: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_sender_setting_input_object']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_sender_setting" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_sender_setting_input_object' is set
        if ('update_sender_setting_input_object' not in params or
                params['update_sender_setting_input_object'] is None):
            raise ValueError("Missing the required parameter `update_sender_setting_input_object` when calling `update_sender_setting`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_sender_setting_input_object' in params:
            body_params = params['update_sender_setting_input_object']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/sender/settings', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_template(self, update_template_input_object, id, **kwargs):  # noqa: E501
        """Update a template  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_template(update_template_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateTemplateInputObject update_template_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_template_with_http_info(update_template_input_object, id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_template_with_http_info(update_template_input_object, id, **kwargs)  # noqa: E501
            return data

    def update_template_with_http_info(self, update_template_input_object, id, **kwargs):  # noqa: E501
        """Update a template  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_template_with_http_info(update_template_input_object, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UpdateTemplateInputObject update_template_input_object: (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['update_template_input_object', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'update_template_input_object' is set
        if ('update_template_input_object' not in params or
                params['update_template_input_object'] is None):
            raise ValueError("Missing the required parameter `update_template_input_object` when calling `update_template`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_template_input_object' in params:
            body_params = params['update_template_input_object']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/templates/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_avatar(self, image, **kwargs):  # noqa: E501
        """Upload an avatar  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_avatar(image, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image: User avatar. Should be PNG or JPG file not more than 10 MB (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_avatar_with_http_info(image, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_avatar_with_http_info(image, **kwargs)  # noqa: E501
            return data

    def upload_avatar_with_http_info(self, image, **kwargs):  # noqa: E501
        """Upload an avatar  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_avatar_with_http_info(image, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image: User avatar. Should be PNG or JPG file not more than 10 MB (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_avatar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image' is set
        if ('image' not in params or
                params['image'] is None):
            raise ValueError("Missing the required parameter `image` when calling `upload_avatar`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in params:
            local_var_files['image'] = params['image']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/user/avatar', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_contact_avatar(self, image, id, **kwargs):  # noqa: E501
        """Upload an avatar  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_contact_avatar(image, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image: Contact avatar. Should be PNG or JPG file not more than 10 MB (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_contact_avatar_with_http_info(image, id, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_contact_avatar_with_http_info(image, id, **kwargs)  # noqa: E501
            return data

    def upload_contact_avatar_with_http_info(self, image, id, **kwargs):  # noqa: E501
        """Upload an avatar  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_contact_avatar_with_http_info(image, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image: Contact avatar. Should be PNG or JPG file not more than 10 MB (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_contact_avatar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image' is set
        if ('image' not in params or
                params['image'] is None):
            raise ValueError("Missing the required parameter `image` when calling `upload_contact_avatar`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `upload_contact_avatar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in params:
            local_var_files['image'] = params['image']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/contacts/{id}/avatar', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_list_avatar(self, image, id, **kwargs):  # noqa: E501
        """Add an avatar for the list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_list_avatar(image, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image: List avatar. Should be PNG or JPG file not more than 10 MB (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_list_avatar_with_http_info(image, id, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_list_avatar_with_http_info(image, id, **kwargs)  # noqa: E501
            return data

    def upload_list_avatar_with_http_info(self, image, id, **kwargs):  # noqa: E501
        """Add an avatar for the list  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_list_avatar_with_http_info(image, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file image: List avatar. Should be PNG or JPG file not more than 10 MB (required)
        :param int id: (required)
        :return: ResourceLinkResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['image', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_list_avatar" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'image' is set
        if ('image' not in params or
                params['image'] is None):
            raise ValueError("Missing the required parameter `image` when calling `upload_list_avatar`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `upload_list_avatar`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'image' in params:
            local_var_files['image'] = params['image']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/lists/{id}/avatar', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResourceLinkResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_message_attachment(self, file, **kwargs):  # noqa: E501
        """Upload message attachment  # noqa: E501

        Upload a new file to insert it as a link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_message_attachment(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx & .vcf file formats (required)
        :return: UploadMessageAttachmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_message_attachment_with_http_info(file, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_message_attachment_with_http_info(file, **kwargs)  # noqa: E501
            return data

    def upload_message_attachment_with_http_info(self, file, **kwargs):  # noqa: E501
        """Upload message attachment  # noqa: E501

        Upload a new file to insert it as a link.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_message_attachment_with_http_info(file, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param file file: Attachment. Supports .jpg, .gif, .png, .pdf, .txt, .csv, .doc, .docx, .xls, .xlsx, .ppt, .pptx & .vcf file formats (required)
        :return: UploadMessageAttachmentResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_message_attachment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `upload_message_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/messages/attachment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UploadMessageAttachmentResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
